{"meta":{"title":"Liwei's Tech Blog","subtitle":"","description":"每天都要学习到晕厥","author":"Li Wei","url":"http://www.li2ui2.xyz","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-11-19T13:52:16.512Z","updated":"2020-11-19T08:16:21.948Z","comments":false,"path":"/404.html","permalink":"http://www.li2ui2.xyz/404.html","excerpt":"","text":""},{"title":"书单","date":"2020-11-20T03:21:35.917Z","updated":"2020-11-19T08:16:21.953Z","comments":false,"path":"books/index.html","permalink":"http://www.li2ui2.xyz/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-11-19T13:47:26.857Z","updated":"2020-11-19T08:16:21.953Z","comments":false,"path":"categories/index.html","permalink":"http://www.li2ui2.xyz/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-11-20T07:05:51.601Z","updated":"2020-11-20T07:05:51.601Z","comments":false,"path":"about/index.html","permalink":"http://www.li2ui2.xyz/about/index.html","excerpt":"","text":"对我的网站或者技术博客有任何意见的欢迎评论交流。以下为我的至2020年个人简历，若显示不全，请点击传送门："},{"title":"标签","date":"2022-09-14T14:36:01.695Z","updated":"2020-11-19T08:16:21.959Z","comments":false,"path":"tags/index.html","permalink":"http://www.li2ui2.xyz/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-01-04T04:44:20.189Z","updated":"2020-11-19T08:16:21.957Z","comments":false,"path":"repository/index.html","permalink":"http://www.li2ui2.xyz/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-09-14T14:31:42.062Z","updated":"2020-11-19T08:16:21.956Z","comments":true,"path":"links/index.html","permalink":"http://www.li2ui2.xyz/links/index.html","excerpt":"","text":""}],"posts":[{"title":"Netgear路由器救砖教程","slug":"Netgear路由器救砖教程","date":"2021-01-04T07:52:06.000Z","updated":"2021-01-04T07:52:48.804Z","comments":true,"path":"2021/01/04/Netgear路由器救砖教程/","link":"","permalink":"http://www.li2ui2.xyz/2021/01/04/Netgear%E8%B7%AF%E7%94%B1%E5%99%A8%E6%95%91%E7%A0%96%E6%95%99%E7%A8%8B/","excerpt":"","text":"1 引言积跬步以至千里，积怠情以至深渊，我要做一个踏实的ABCer。 本文将介绍在Netgear路由器刷机失败或因不明原因而导致路由器变砖后的救砖教程。下边将以本人使用的Netgear R6220为例，进行讲解。 2 救砖过程 下载nmrpflash.exe工具链接：https://pan.baidu.com/s/140aE74ZUsRMcW1sbdLYqYQ，提取码：opw4 根据Netgear路由器设备的型号，下载对应的img文件（固件），该文件可在OpenWrt官网，或者Netgear官网下找到。 在Windows下以管理员身份打开命令提示符。 使用网线插上lan口 输入命令nmrpflash.exe -L查询网卡编号，如本人查询到的编号为net3。 查询好编号后，执行命令nmrpflash.exe -i net3 -f R6220-V1.1.0.86.img开启救砖之路，值得注意的是，此命令执行的时机为：在命令提示符中输入好指令后，此时路由在处于关机状态，接着按下回车，在按回车的一瞬间开启路由器电源，大概等待1-5分钟左右的时间，即可恢复成功。命令执行时机决定救砖是否成功，可以不断尝试，直到成功。","categories":[{"name":"技巧","slug":"技巧","permalink":"http://www.li2ui2.xyz/categories/%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"Netgear路由器","slug":"Netgear路由器","permalink":"http://www.li2ui2.xyz/tags/Netgear%E8%B7%AF%E7%94%B1%E5%99%A8/"}]},{"title":"树莓派(二) 树莓派开启VNC远程连接服务","slug":"树莓派-二-树莓派开启VNC远程连接服务","date":"2021-01-04T07:48:17.000Z","updated":"2021-01-04T07:50:22.692Z","comments":true,"path":"2021/01/04/树莓派-二-树莓派开启VNC远程连接服务/","link":"","permalink":"http://www.li2ui2.xyz/2021/01/04/%E6%A0%91%E8%8E%93%E6%B4%BE-%E4%BA%8C-%E6%A0%91%E8%8E%93%E6%B4%BE%E5%BC%80%E5%90%AFVNC%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1/","excerpt":"","text":"1. 启用树莓派 VNC 服务在树莓派命令行终端执行如下命令： 1sudo raspi-config 出现如下界面：依次操作：Interfacing Options -&gt; VNC -&gt; Yes。之后系统会提示你是否要安装 VNC 服务，输入 y 之后回车，等待系统自动下载安装完成，一切顺利的话 VNC 服务就启动了！在树莓派命令行终端执行如下命令查看VNC server的连接地址： 1sudo raspi-config 查看发现连接地址为：192.168.50.2:1 2. 安装 VNC 客户端以上启用的VNC Server的方式为树莓派自带的vnc server，它的加密方式和tigerVNC viewer不兼容，会显示以下错误： Unknown authentication scheme from VNC server: 13, 5, 6, 130, 192 使用realVNC客户端才能正常访问，RealVNC Viewer客户端安装（根据客户端系统进行安装）。或者可以考虑在树莓派上安装tightvncserver。 linux系统下安装方式到官网下载版本DEB X64对安装目录下打开终端，执行如下命令进行安装： 1sudo dpkg -i VNC-Viewer-6.20.113-Linux-x64.deb 安装完成后，打开VNC应用，输入VNC Server服务器的地址，进行远程连接，效果如下（左侧为VNC客户端管理台，右侧为远程连接得到的桌面）：","categories":[{"name":"树莓派","slug":"树莓派","permalink":"http://www.li2ui2.xyz/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"}],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"http://www.li2ui2.xyz/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"}]},{"title":"树莓派(一) 树莓派中的网络配置问题","slug":"树莓派-一-树莓派中的网络配置问题","date":"2021-01-04T07:47:49.000Z","updated":"2021-01-04T07:49:35.497Z","comments":true,"path":"2021/01/04/树莓派-一-树莓派中的网络配置问题/","link":"","permalink":"http://www.li2ui2.xyz/2021/01/04/%E6%A0%91%E8%8E%93%E6%B4%BE-%E4%B8%80-%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/","excerpt":"","text":"1 引言积跬步以至千里，积怠情以至深渊。 本文将介绍树莓派的相关网络配置。 2. 树莓派设置静态IP配置信息如下： 1234567891011121314151617# 打开interfaces进行配置sudo vim /etc/network/interfaces# 把文件里的信息替换成下面的，填好自己需要的ip，网关、掩码，DNS等等auto loiface lo inet loopbackauto eth0iface eth0 inet staticaddress 192.168.50.2 # 静态IP地址gateway 192.168.50.1 # netstat -rn命令或者route -n查看现有的netmask 255.255.255.0 # 掩码 # dns-nameserver 8.8.8.8 # DNS服务器的地址auto wlan0iface wlan0 inet dhcpwpa-conf /etc/wpa.confiface default inet dhcp 保存以上配置信息后，创建sudo vim /etc/wpa.conf文件，添加内容如下： 1234567891011# 在无线不设密码情况下，添加如下代码network=&#123; ssid=&quot;你的WiFi名称&quot; key_mgmt=NONE&#125;# 在无线设置代码的情况下，添加如下代码network=&#123; ssid=&quot;你的WiFi名称&quot; key_mgmt=WPA-PSK psk=&quot;你的WiFi密码&quot;&#125; 配置保存完以上信息后，需要执行如下操作： 1234567# 启用无线网卡sudo ifup wlan0# 重启网络：sudo /etc/init.d/networking restart# sudo service networking restart# 这时查看的就修改好的配置信息了。# 或者重启电脑：sudo reboot 3. 可能会用到的操作12345ip route # 查看当前网络下的路由表ip route delete 192.168.x.x # 删除某一条路由表条目ip route delete 192.168.x.x # 增加某一条路由表条目ip route delete default via 192.168.x.x # 删除某一条网关ip route add default via 192.168.x.x # 增加某一条网关","categories":[{"name":"树莓派","slug":"树莓派","permalink":"http://www.li2ui2.xyz/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"}],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"http://www.li2ui2.xyz/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"}]},{"title":"Pytharm中关于版本控制的使用","slug":"Pytharm中关于版本控制的使用","date":"2021-01-04T07:45:35.000Z","updated":"2021-01-04T07:47:04.702Z","comments":true,"path":"2021/01/04/Pytharm中关于版本控制的使用/","link":"","permalink":"http://www.li2ui2.xyz/2021/01/04/Pytharm%E4%B8%AD%E5%85%B3%E4%BA%8E%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"引言积跬步以至千里，积怠情以至深渊。 本文主要针对个人使用Pycharm中的版本控制过程中遇到的问题进行的记录。 Pycharm拉取Github项目Pycharm可远程拉取Github项目进行本地管理，主要流程介绍如下： 打开Pycharm，选择Get from Version Control 可通过选择不同的版本控制方式进行clone项目，也可以直接远程拉取GitHub项目（GitHub账号在Pycharm中需要事先登录） 之后在Clone下来的项目中即可进行版本控制，主要流程为add –&gt; commit –&gt; push Pycharm中创建本地项目，上传GitHubPS:之前处理过，忘记记录了，等过段时间闲下来，好好记录一下！","categories":[{"name":"技巧","slug":"技巧","permalink":"http://www.li2ui2.xyz/categories/%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"Pycharm","slug":"Pycharm","permalink":"http://www.li2ui2.xyz/tags/Pycharm/"}]},{"title":"Python(四) Python中的闭包函数、可变参数和装饰器","slug":"Python-四-Python中的闭包函数、可变参数和装饰器","date":"2021-01-04T07:43:54.000Z","updated":"2021-01-04T07:44:26.048Z","comments":true,"path":"2021/01/04/Python-四-Python中的闭包函数、可变参数和装饰器/","link":"","permalink":"http://www.li2ui2.xyz/2021/01/04/Python-%E5%9B%9B-Python%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E3%80%81%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/","excerpt":"","text":"1.闭包函数闭包函数，简而言之就是内部函数引用了外部函数中的变量。常用的方式时将函数名作为返回值返回。下面将给出例程及其注释。 123456789def func(): name = &#x27;Python&#x27; # 外部变量 def inner(): print(name) print(inner.__closure__) # 调用内置方法查看该函数是否为闭包函数 return inner # 将函数名作为返回值f = func() # 此时，f得到了func的返回值inner，因此f=innerf() # 此时相当于调用了inner函数# 输出结果为：Python 2.装饰器2.1单个装饰器123456789101112131415161718def w1(func): # w1接收参数func， 实际上为一个方法名。 # w1内部定义了一个inner函数。执行完输出语句print(&#x27;...验证权限...&#x27;)后， # 调用参数func，且其返回值为inner def inner(): print(&#x27;...验证权限...&#x27;) func() return inner# 当Python执行到@w1这句时，调用w1，同时将被装饰的函数名作为参数传入f(1)。# 在执行w1时，返回inner函数，同时将其赋值给f1，此时，f1=w1(f1)@w1def f1(): print(&#x27;f1 called&#x27;)f1() # 此时，相当于调用w1.inner，先输出，再执行原f1# 输出： # ...验证权限...# f1 called 2.2多个装饰器123456789101112131415161718192021222324252627282930313233# 多个修饰器def makeBold(fun): print(&#x27;----a----&#x27;) def inner(): print(&#x27;----1----&#x27;) # print(fun()) return &#x27;&lt;b&gt;&#x27; + fun() + &#x27;&lt;/b&gt;&#x27; return innerdef makeItalic(fun): print(&#x27;----b----&#x27;) def inner(): print(&#x27;----2----&#x27;) # print(fun()) return &#x27;&lt;i&gt;&#x27; + fun() + &#x27;&lt;/i&gt;&#x27; return inner# 1.程序执行到@makeBold时，需要对下面的函数进行修饰，但发现下面并不是一个函数，# 而有是一个装饰器，这时应暂停@makeBold装饰器的执行.# 2.接着执行装饰器@makeItalic，并把ttest函数名传入装饰器函数，# 此时先输出：----b----，并且此时的ttest指向makeItalic的inner函数地址(ttest1)# 3.接着返回执行@makeBold，把ttest1传入makeBold装饰器函数中# 此时输出：----a----，此时的ttest1指向makeBold.inner函数(ttest2)，并输出：----1----# 4.在ttest2中接着要调用fun()时,实际上是执行ttest1内容，# 此时输出：----2----，并且执行ttest函数，并输出：----c----和----3----# 同时返回结果：&lt;i&gt;hello python decorator&lt;/i&gt;# 5.接着执行ttest2未执行完成的语句，返回结果给ret：&lt;b&gt;&lt;i&gt;hello python decorator&lt;/i&gt;&lt;/b&gt; @makeBold @makeItalicdef ttest(): print(&#x27;----c----&#x27;) print(&#x27;----3----&#x27;) return &#x27;hello python decorator&#x27;ret = ttest()print(ret) 2.3 对有参数函数进行装饰2.1和2.2为对无参数函数的装饰 123456789101112131415161718192021def w_add(func): def inner(*args, **kwargs): print(&#x27;add inner called&#x27;) func(*args, **kwargs) return inner@w_adddef add(a, b): print(&#x27;%d + %d = %d&#x27; % (a, b, a + b))@w_adddef add2(a, b, c): print(&#x27;%d + %d + %d = %d&#x27; % (a, b, c, a + b + c))add(2, 4)add2(2, 4, 6)&quot;&quot;&quot;输出结果为：add inner called2 + 4 = 6add inner called2 + 4 + 6 = 12&quot;&quot;&quot; NT:位置参数： 当我们声明一个诸如*args的星号参数时，从此处开始直到结束的所有位置参数都将被收集并汇集成一个称为“args”的元组（Tuple) 123456def argsFunc(*my_args): print(my_args)&gt;&gt;&gt; argsFunc(1, 2, 3, 4)(1, 2, 3, 4)&gt;&gt;&gt; argsFunc()() 关键字 参数: 当我们声明一个诸如**kwargs的双星号参数时，从此处开始直至结束的所有关键字参数都将被收集并汇集成一个名为 kwargs的字典（Dictionary） 12345678def argsFunc(**my_args): print(my_args)&gt;&gt;&gt; argsFunc(X=1, Y=2, Z=3)&#123;&#x27;X&#x27;: 1, &#x27;Y&#x27;: 2, &#x27;Z&#x27;: 3&#125;&gt;&gt;&gt; argsFunc()&#123;&#125;&gt;&gt;&gt; argsFunc(1,2,3) #这种调用则报错TypeError: argsFunc() takes 0 positional arguments but 3 were given 2.4 对带有返回值的函数进行装饰1234567891011121314151617181920def w_test(func): def inner(): print(&#x27;w_test inner called start&#x27;) str = func() print(&#x27;w_test inner called end&#x27;) return str return inner@w_testdef test(): print(&#x27;this is test fun&#x27;) return &#x27;hello&#x27;ret = test()print(&#x27;ret value is %s&#x27; % ret)&quot;&quot;&quot;输出：w_test inner called startthis is test funw_test inner called endret value is hello&quot;&quot;&quot; 2.5 带有参数的装饰器123456789101112131415def func_args(pre=&#x27;xiaoqiang&#x27;): def w_test_log(func): def inner(): print(&#x27;...记录日志...visitor is %s&#x27; % pre) func() return inner return w_test_log# 带有参数的装饰器能够起到在运行时，有不同的功能# 先执行func_args(&#x27;wangcai&#x27;)，返回w_test_log函数的引用# @w_test_log# 使用@w_test_log对test_log进行装饰@func_args(&#x27;wangcai&#x27;)def test_log(): print(&#x27;this is test log&#x27;)test_log() 2.6 类装饰器当python解释器执行到到@Test时，会把当前test函数作为参数传入Test对象，调用init方法，同时将test函数指向创建的Test对象，那么在接下来执行test()的时候，其实就是直接对创建的对象进行调用，执行其call方法。 123456789101112class Test(object): def __init__(self, func): print(&#x27;test init&#x27;) print(&#x27;func name is %s &#x27; % func.__name__) self.__func = func def __call__(self, *args, **kwargs): print(&#x27;装饰器中的功能&#x27;) self.__func()@Testdef test(): print(&#x27;this is test func&#x27;)test() 参考链接https://www.cnblogs.com/slysky/p/9777424.html","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://www.li2ui2.xyz/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.li2ui2.xyz/tags/Python/"}]},{"title":"Python(三) 数据类型ndarray、series和dataframe之间的相互转换","slug":"Python-三-数据类型ndarray、series和dataframe之间的相互转换","date":"2021-01-04T07:41:27.000Z","updated":"2021-01-04T07:42:10.616Z","comments":true,"path":"2021/01/04/Python-三-数据类型ndarray、series和dataframe之间的相互转换/","link":"","permalink":"http://www.li2ui2.xyz/2021/01/04/Python-%E4%B8%89-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bndarray%E3%80%81series%E5%92%8Cdataframe%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"介绍&#160; &#160; &#160; &#160;在大数据分析中，比较常用的两个数据分析包就是Numpy和Pandas，而Pandas正是基于Numpy构建的含有更高级数据结构和工具的数据分析包。 ndarray数据结构：ndarray是Numpy中的数据结构，是一个多维数组，可以理解为矩阵，具有矢量运算能力，快速、节省空间 dataframe数据结构：dataframe是Pandas中的数据结构，Pandas主要用于读取csv格式的文件，读取后数据文件格式为dataframe结构 series和dataframe数据结构series数据结构是dataframe中的一列或者一行 数据类型转换1、输入数据为list时 2、输入数据为dict时 3、输入的数据data为ndarray 本文部分内容转载自http://www.lining0806.com/numpy%E7%9A%84ndarray%E4%B8%8Epandas%E7%9A%84series%E5%92%8Cdataframe%E4%B9%8B%E9%97%B4%E4%BA%92%E8%BD%AC/","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://www.li2ui2.xyz/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.li2ui2.xyz/tags/Python/"}]},{"title":"AI(一) 运用MTCNN和Facenet模型实现人脸识别和检测","slug":"AI-一-运用MTCNN和Facenet模型实现人脸识别和检测","date":"2021-01-04T07:38:13.000Z","updated":"2021-01-04T07:40:24.413Z","comments":true,"path":"2021/01/04/AI-一-运用MTCNN和Facenet模型实现人脸识别和检测/","link":"","permalink":"http://www.li2ui2.xyz/2021/01/04/AI-%E4%B8%80-%E8%BF%90%E7%94%A8MTCNN%E5%92%8CFacenet%E6%A8%A1%E5%9E%8B%E5%AE%9E%E7%8E%B0%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E5%92%8C%E6%A3%80%E6%B5%8B/","excerpt":"","text":"引言积跬步以至千里，积怠情以至深渊。 这应该算是本人第一篇用心写的博客了。网上也已经有很多关于人脸识别的博客，但是受某票圈各位大佬的影响，还是决定把刚完成的CV课程的大作业在这里写篇博客做个详细的记录，也算是总结下收获和体验了。这其中也参考了很多大佬的博客，感谢路过的各位大佬批评指正。 这篇博客的内容关于本人在实现人脸识别系统过程中的一些总结以及感悟，这其中包括部分源自Google的Facenet的源码解读、个人在实现人脸识别时经过学习总结的一些思路以及部分代码片段分享等内容。 整体思路参考论文主要参考了文献：1.FaceNetSchroff F, Kalenichenko D, Philbin J. Facenet: A unified embedding for face recognition and clustering[C]//Proceedings of the IEEE conference on computer vision and pattern recognition. 2015: 815-823. 2.MTCNNZhang K, Zhang Z, Li Z, et al. Joint face detection and alignment using multitask cascaded convolutional networks[J]. IEEE Signal Processing Letters, 2016, 23(10): 1499-1503. 3.《如何应用 MTCNN 和 FaceNet 模型实现人脸检测及识别》https://www.infoq.cn/article/how-to-achieve-face-recognition-using-mtcnn-and-facenet NT：关于论文的解读这里就不再赘述，网上已经有大量的分析。 Facenet推理过程Facenet这是谷歌的一个开源项目，实现了将输入的人像最终转换为shape为1*128的向量，而后通过计算不同照片之间的欧几里德距离来判他们的相似度。预训练模型请戳这里下载 MTCNN该模型是一个Multi-task的人脸检测框架，使用了3个CNN级联算法结构，将人脸检测和人脸特征点检测同时进行。需要经历Resize、P-Net、R-Net、O-Net四个阶段。简单的说，这就是一个检测图片中人脸位置的一个模型。 实现流程1.通过MTCNN人脸检测模型，从照片中提取人脸图像 12345678910111213141516171819202122232425262728293031323334353637#返回提取后的图像def get_crop_image(image_paths, image_size, margin, gpu_memory_fraction) minsize = 20 # minimum size of face threshold = [ 0.6, 0.7, 0.7 ] # three steps&#x27;s threshold factor = 0.709 # scale factor print(&#x27;创建网络，并载入相关参数：&#x27;) with tf.Graph().as_default(): gpu_options = tf.GPUOptions(per_process_gpu_memory_fraction=gpu_memory_fraction) sess = tf.Session(config=tf.ConfigProto(gpu_options=gpu_options, log_device_placement=False)) with sess.as_default(): pnet, rnet, onet = align.detect_face.create_mtcnn(sess, None) img_list = [] for image in image_paths: print(image img = misc.imread(image, mode=&#x27;RGB&#x27;) img_size = np.asarray(img.shape)[0:2] bounding_boxes, _ = align.detect_face.detect_face(img, minsize, pnet, rnet, onet, threshold, factor) if len(bounding_boxes) &lt; 1: image_paths.remove(image) print(&quot;无法检测到人脸，并移除图像 &quot;, image) continue det = np.squeeze(bounding_boxes[0,0:4]) bb = np.zeros(4, dtype=np.int32) bb[0] = np.maximum(det[0]-margin/2, 0) bb[1] = np.maximum(det[1]-margin/2, 0) bb[2] = np.minimum(det[2]+margin/2, img_size[1]) bb[3] = np.minimum(det[3]+margin/2, img_size[0]) cropped = img[bb[1]:bb[3],bb[0]:bb[2],:] # 根据cropped位置对原图resize，并对新得的aligned进行白化预处理 aligned = misc.imresize(cropped, (image_size, image_size), interp=&#x27;bilinear&#x27;) prewhitened = facenet.prewhiten(aligned) img_list.append(prewhitened) images = np.stack(img_list) return images 2.把人脸图像输入到Facenet中，计算Embedding的特征向量 1234567891011121314151617181920# Get input and output tensorimages_placeholder = tf.get_default_graph().get_tensor_by_name(&quot;input:0&quot;)embeddings = tf.get_default_graph().get_tensor_by_name(&quot;embeddings:0&quot;)phase_train_placeholder =tf.get_default_graph().get_tensor_by_name(&quot;phase_train:0&quot;)image=[]nrof_images=0#该路径为mtcnn模型训练后得到的图像的存储路径emb_dir=&#x27;E:\\\\WorkSpace\\\\PycharmProject\\\\face_recognition_system\\\\embed_img&#x27;all_img=[]for i in os.listdir(emb_dir): all_img.append(i) img = misc.imread(os.path.join(emb_dir,i), mode=&#x27;RGB&#x27;) prewhitened = facenet.prewhiten(img) image.append(prewhitened) nrof_images=nrof_images+1images=np.stack(image)feed_dict = &#123; images_placeholder: images, phase_train_placeholder:False &#125;compare_emb = sess.run(embeddings, feed_dict=feed_dict)compare_num=len(compare_emb) 3.比较特征向量间的欧式距离，判断是否为同一个人。例如当距离小于1时，则认为时同一个人。在进行比较时，需要计算带比较人脸的特征向量。 结合OpenCV实现实时人脸识别系统关于OpenCV的一点干货呃…还是直接看本人在github上分享的关于OpenCV简单功能实现的代码片段吧！！下面介绍一款可以调用手机摄像头的APP，并结合OpenCV使用，IPhone手机亲测可用。苹果手机直接下载IP摄像头 简化版即可，可不用下载付费款的。下载完成后，打开软件，点击打开IP摄像头服务器，而后出现以下界面，记下红框中的IP地址。然后就是结合OpenCV使用的部分代码了： 123456789# 开启ip摄像头# 此处@后的ipv4 地址需要修改为上面记下的IP地址，并且客户端与手机需要连接在同一个局域网下video = &quot;http://admin:admin@192.XXX.XXX.XXX:8081/&quot; # 参数为0表示打开内置摄像头，参数是视频文件路径则打开视频capture = cv2.VideoCapture(video)cv2.namedWindow(&quot;camera&quot;, 1)while True: ret, frame = capture.read() cv.imshow(title, frame) 相信，在搞懂本人在github上上传的代码片段以及以上代码，怎么实现实时人脸识别系统，就可以根据自己想要的设计开发属于自己的人脸识别系统啦。至于识别精度方面。。相信谷歌。。亲测。。说可以也还可以。。说不可以也还真不可以。。 人脸识别结果人脸识别结果的展示： 1.只要检测到人脸框就进行标注 图1 合照中的人脸识别 图2 个人照中的人脸识别 2.展示检测到的图像中最大的人脸 利用mtcnn计算图片中检测到的所有人脸框中最大的一个人脸框，并显示其身份。 图3 大脸识别 相关代码片段，其中det为调用align.detect_face.detect_face函数后得到的返回值，并进行相关处理后的结果： 12345678910111213141516171819202122#找最大矩形框for rec_position in range(len(det)): a = abs(det[rec_position, 0]-det[rec_position, 2]) b = abs(det[rec_position, 1]-det[rec_position, 3]) s = a*b if s &gt; max_area: max_area = s max_area_point = [det[rec_position, 0],det[rec_position, 1], det[rec_position, 2],det[rec_position, 3]]#绘制矩形框cv2.rectangle(frame, (max_area_point[0], max_area_point[1]), (max_area_point[2], max_area_point[3]), (0, 255, 0), 2, 8, 0)#在左上角输出对应信息cv2.putText( frame, result[rec_position], (max_area_point[0], max_area_point[1]), cv2.FONT_HERSHEY_COMPLEX_SMALL, 0.8, (0, 0, 255), thickness=2, lineType=2) 3 在识别到最大人脸框后，将这个人在里对应的最像的照片缩小叠加显示在边上 图4 大脸识别并找最相似人脸 验证人脸识别的准确率在做人脸识别任务时，常常会用ROC曲线、CMC曲线作为实验性能指标。根据以下绘图结果以及实时测试，该人脸识别实时系统的识别精度为98.72%，由于个人PC配置问题，实时视频后期会出现卡顿现象。 ROC曲线相关定义ROC（Receiver Operating Characteristic）曲线，以及AUC（Area Under Curve），常用来评价一个二值分类器的优劣，ROC的横轴为false positive rate，FPR，也就是实例是负类被预测为正类的比例；纵轴是true positive rate，TPR， 也就是实例是正类被预测为正类的比例。AUC被定义为时ROC曲线下的面积，可用于评价模型性能，AUC值越接近于1，表示模型越好。 曲线绘制1.Labeled Faces in the Wild, LFW在开源的facenet源码中，给出了针对LFW数据的ROC计算代码，代码相关解释可参考博客，而后通过调用lfw数据集的路径以及对应的pairs.txt文件即可绘制出ROC曲线，结果如下： 图5 LFW数据集对应的ROC曲线 由于公开的facenet模型正是基于LFW数据集训练得到的模型，所以使用该数据集再进行性能检测时得到的AUC值为1，模型几乎完美。 呃。。。。 2 绘制其他数据集，比如 AT&amp;T “The Database of Faces”Facenet源码中对ROC的计算时针对LFW数据集的，要想使用其他数据集，就必须自己造pairs.txt文件。这里选用了att_face数据集，制作其pairs.txt格式文件步骤如下： 首先是Facenet源码中的pairs.txt格式文件解读： 图6 Facenet源码中的pairs.txt格式文件解读 数据集中的样本图片格式及名称的修改：att_face数据集数据集中的图片格式是.pgm格式，将其转化成.jpg格式，并将每张图片路径存为…/s1/s1_0001.jpg格式。实现代码如下 123456789101112131415161718192021222324252627282930def batch_image(in_dir, out_dir): if not os.path.exists(out_dir): print(out_dir, &#x27;is not existed.&#x27;) os.mkdir(out_dir) if not os.path.exists(in_dir): print(in_dir, &#x27;is not existed.&#x27;) return -1 count = 0 for dir in os.listdir(in_dir): path = os.path.join(in_dir,dir) for files in glob.glob(path + &#x27;/*&#x27;): #返回路径基名和路径目录名 filepath, filename = os.path.split(files) out_file = dir + &#x27;_000&#x27;+ re.findall(r&#x27;\\d+&#x27;,filename[0:9])[0] + &#x27;.jpg&#x27; im = Image.open(files) new_path1 = out_dir + &#x27;\\\\&#x27;+ dir if not os.path.exists(new_path1): print(new_path1, &#x27;is not existed.&#x27;) os.mkdir(new_path1) new_path = os.path.join(new_path1, out_file) print(count, &#x27;,&#x27;, new_path) count = count + 1 im.save(new_path)if __name__ == &#x27;__main__&#x27;: indir = r&#x27;E:\\WorkSpace\\PycharmProject\\face_recognition_system\\ROC_PLOT\\Data_Transfer\\att_faces&#x27; outdir = r&#x27;E:\\WorkSpace\\PycharmProject\\face_recognition_system\\ROC_PLOT\\Data_Transfer\\dataset&#x27; batch_image(indir, outdir) 生成数据集对应的pairs.txt： 12345678910111213141516171819202122232425import osimport randomdataset_path = &quot;E:/WorkSpace/PycharmProject/face_recognition_system/ROC_PLOT/Data_Transfer/s_data/&quot;pairs_generate_path = &quot;E:/WorkSpace/PycharmProject/face_recognition_system/ROC_PLOT/Data_Transfer/pairs.txt&quot;# Make all matchesfor name in os.listdir(dataset_path): a = [] for file in os.listdir(dataset_path + name): a.append(file) with open(pairs_generate_path, &quot;a&quot;) as f: for i in range(5): temp = random.choice(a).split(&quot;_&quot;) #根据自己图片的命名格式更改这行代码 w = temp[0] + &quot;_&quot; + temp[1] f.write(temp[0] + &quot;\\t&quot; + random.choice(a).split(&quot;_&quot;)[1].lstrip(&quot;0&quot;).rstrip(&quot;.jpg&quot;) + &quot;\\t&quot; + random.choice(a).split(&quot;_&quot;)[1].lstrip(&quot;0&quot;).rstrip(&quot;.jpg&quot;) + &quot;\\n&quot;)# Make all mismatchesfor i,name in enumerate(os.listdir(dataset_path)): remaining = os.listdir(dataset_path) del remaining[i] # 删除对应索引的元素，以免重复选取 other_dir = random.choice(remaining) with open(pairs_generate_path,&quot;a&quot;) as f: for i in range(5): file1 = random.choice(os.listdir(dataset_path + name)) file2 = random.choice(os.listdir(dataset_path + other_dir)) f.write(name + &quot;\\t&quot; + file1.split(&quot;_&quot;)[1].lstrip(&quot;0&quot;).rstrip(&quot;.jpg&quot;) + &quot;\\t&quot; + other_dir + &quot;\\t&quot; + file2.split(&quot;_&quot;)[1].lstrip(&quot;0&quot;).rstrip(&quot;.jpg&quot;) + &quot;\\n&quot;) 3 针对自己构建的分类器模型，测试任意数据集的ROC曲线 本次人脸识别过程中构建了SVM线性分类器对录入人脸类别进行了42个分类，以提供识别，后期亦可添加。多分类下的ROC曲线的绘制有别于二分类，详情参考了博客。绘制结果如下，从结果可以看出，精度还是相当高的，但是若每个类别下的人脸图像数据过少，识别精度就很有可能急剧下降。 图7 SVM分类器训练模型下的ROC曲线 CMC曲线相关定义全称为Cumulative Match Characteristic Curve, 也就是累积匹配曲线。其评价指标与DL中常用的top error1评价指标一样的意思，区别在于横坐标Rank表示正确率而不是错误率(Rank1识别率 = 1 - top1 err), 更多不再解释，网上有很多这里举个例子： 我们训练了一个分类器，来识别五个物体，即1，2，3，4，5，他们属于三类即A,B,C。经过分类预测，如果物体1，2为一次就命中，3，4为两次才能命中，5为三次命中，则rank1为40%、rank2为80%、rank3为100%。 曲线绘制Python下实现CMC曲线绘制的教程还是比较少的，这里给出实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*- coding: utf-8 -*-from sklearn.externals import joblibimport matplotlib.pyplot as pltimport trainimport numpy as npfrom sklearn.preprocessing import label_binarize# CMC曲线# 需要提供confidence_values和y_test这两个变量X_test = train.X_testy_test_ = train.y_testmodel = joblib.load(&#x27;./models/svm_classifier.model&#x27;)# 得到每个样本在每个标签下的置信值，返回的confidence_values为模型预测得到的匹配置信分数矩阵confidence_values = model.decision_function(X_test)# 将标签二值化,返回一个one-hot标签矩阵y_test= label_binarize(y_test_, classes=[i for i in range(42)])# 保存accuracy，记录rank1到rank42的准确率test_cmc = []# y_test为测试样本的真实标签矩阵；返回每行真实标签相对应的最大值的索引值actual_index = np.argmax(y_test,1)#返回每行预测标签相对应的最大值的索引值predict_index = np.argmax(confidence_values,1)# 若为1代表相同，一次命中；0代表不同，第一次猜测并未命中temp = np.cast[&#x27;float32&#x27;](np.equal(actual_index,predict_index))# rank1test_cmc.append(np.mean(temp))# 按行降序排序，返回匹配分数值从大到小的索引值sort_index = np.argsort(-confidence_values,axis=1)# rank2到rank42for i in range(sort_index.shape[1]-1): for j in range(len(temp)): if temp[j]==0: predict_index[j] = sort_index[j][i+1] temp = np.cast[&#x27;float32&#x27;](np.equal(actual_index,predict_index)) test_cmc.append(np.mean(temp))#创建绘图对象plt.figure()x = np.arange(0,sort_index.shape[1])plt.plot(x,test_cmc,color=&quot;red&quot;,linewidth=2)plt.xlabel(&quot;Rank&quot;)plt.ylabel(&quot;Matching Rate&quot;)plt.legend()plt.title(&quot;CMC Curve&quot;)plt.show() 绘制曲线结果如下： 图8 SVM分类器训练模型下的ROC曲线 其他参考 facenet源码解析：Triplet Loshttps://zhuanlan.zhihu.com/p/38341541 facenet入门程序：里边包括很多对facenet源码的解读https://github.com/boyliwensheng/understand_facenet pairs.txt文件结构http://vis-www.cs.umass.edu/lfw/README.txt","categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://www.li2ui2.xyz/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"MTCNN人脸检测算法","slug":"MTCNN人脸检测算法","permalink":"http://www.li2ui2.xyz/tags/MTCNN%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/"},{"name":"Facenet人脸识别算法","slug":"Facenet人脸识别算法","permalink":"http://www.li2ui2.xyz/tags/Facenet%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E7%AE%97%E6%B3%95/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://www.li2ui2.xyz/tags/OpenCV/"}]},{"title":"Git(一) Windows下通过Git工具上传本地项目(大文件)到GitHUb上","slug":"Git-一-Windows下通过Git工具上传本地项目-大文件-到GitHUb上","date":"2021-01-04T07:36:09.000Z","updated":"2021-01-04T07:54:52.628Z","comments":true,"path":"2021/01/04/Git-一-Windows下通过Git工具上传本地项目-大文件-到GitHUb上/","link":"","permalink":"http://www.li2ui2.xyz/2021/01/04/Git-%E4%B8%80-Windows%E4%B8%8B%E9%80%9A%E8%BF%87Git%E5%B7%A5%E5%85%B7%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE-%E5%A4%A7%E6%96%87%E4%BB%B6-%E5%88%B0GitHUb%E4%B8%8A/","excerpt":"","text":"上传项目前的准备工作1.安装Gitgit的安装请参考https://blog.csdn.net/weixin_44950987/article/details/102619708 2.绑定用户打开git-bash.exe在打开的GIt Bash中输入以下命令（用户和邮箱为你github注册的账号和邮箱 123&#x2F;&#x2F;设置全局用户git config --global user.name &quot;XXX&quot;git config --global user.email &quot;XXXXXX@zju.edu.cn&quot; 3.设置SSH key3.1生成SSH keyssh是加密传输，通过git-bash.exe在本地生成一对密钥（RSA）用于Git和GitHub之间的数据的传输。这个钥匙需要在github.com中设置。密钥生成方法为： 1ssh-keygen -t rsa -C &quot;XXXXXX@zju.edu.cn&quot; 在生成过程中，一路按3次回车键就好了（默认路径，默认没有密码登录）。生成成功后，去对应目录C:\\Users\\lee.ssh里（lee为电脑用户名，每个人不同）用记事本打开id_rsa.pub，得到ssh key公钥。 3.2为GitHub账号配置SSH key切换到github，展开个人头像的小三角，点击settings，然后打开SSH keys菜单， 点击Add SSH key新增密钥，填上标题（最好跟本地仓库保持一致）。接着将id_rsa.pub文件中key粘贴到此，最后Add key生成密钥吧。 开始上传项目到GitHub上1.创建本地仓库指定本地仓库的路径即可，根据个人存储位置而定 1mkdir &#x2F;e&#x2F;Git&#x2F;My-Repositor 2.进入本地仓库所在得文件夹1cd &#x2F;e&#x2F;Git&#x2F;My-Repository 3.将要上传得整个项目文件夹aaa移至/e/Git/My-Repository进入文件夹内cd aaa执行指令 如下指令，该指令为初始化操作，操作完后项目里会多一个隐藏得文件夹.git 1git init 若要上传大文件，需要执行如下操作，否则跳过执行步骤4。在执行一下步骤前需要安装git-lfs，参考链接。 123456&#x2F;&#x2F;安装git-lfs到本机git lfs install&#x2F;&#x2F;跟踪要push的大文件的文件或指定文件类型。可随时配置其他文件扩展名。&#x2F;&#x2F;这一步成功后会生成一个gitattributes文件。&#x2F;&#x2F;下面的 “ *.a &quot;是上传的大文件的路径。git lfs track “* .a” 4.添加所有文件到本地仓库1234&#x2F;&#x2F;将所有文件添加到仓库git add . &#x2F;&#x2F;设置提交项目时所要添加得注释git commit -m &quot;提交文件&quot; 5.关联Github仓库先到自己github主页里复制仓库地址 https://github.com/XXXX.git，而后执行如下指令 1git remote add origin https:&#x2F;&#x2F;github.com&#x2F;XXXX.git 若已经在github的仓库里添加过文件，如README文件，需要将github上的文件合并到本地仓库，执行指令 1git pull --rebase origin master 6.上传代码为防止上传项目前github仓库禁止访问，在上传项目前，可先执行如下指令 1git config --global credential.helper store 输入Github的账号密码后，执行如下指令开始上传项目 1git push -u origin master","categories":[{"name":"版本控制","slug":"版本控制","permalink":"http://www.li2ui2.xyz/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://www.li2ui2.xyz/tags/Git/"}]},{"title":"数据库(一) Windows下MongoDB的配置及远程连接","slug":"数据库-一-Windows下MongoDB的配置及远程连接","date":"2021-01-04T07:34:11.000Z","updated":"2021-01-04T07:35:00.026Z","comments":true,"path":"2021/01/04/数据库-一-Windows下MongoDB的配置及远程连接/","link":"","permalink":"http://www.li2ui2.xyz/2021/01/04/%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%B8%80-Windows%E4%B8%8BMongoDB%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8F%8A%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/","excerpt":"","text":"基本操作MongoDB的基本安装https://blog.csdn.net/heshushun/article/details/77776706启动和配置MongoDB服务参考博客https://blog.csdn.net/ljk168/article/details/79452895创建MongoDB用户名及账户参考博客https://www.cnblogs.com/wuyubing/p/4897387.html 远程连接MongoDB失败的解决办法 1、mongodb的配置文件中的bind_ip 默认为127.0.0.1，默认只有本机可以连接。 此时，需要将bind_ip配置为0.0.0.0，表示接受任何IP的连接。注意：在 bin目录下的mongo.cfg文件修改 2、防火墙阻止了27017端口 win10下开端口号设置如下：控制面板&gt;系统安全&gt;windows防火墙&gt;高级设置&gt;入站规则&gt;新建规则&gt;端口&gt;tcp 特定端口输入27017&gt;允许链接&gt;按照默认设置或者懂得人可以自己进行其他设置&gt;取规则名确定完成即可。 注意：重启mongod服务。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://www.li2ui2.xyz/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://www.li2ui2.xyz/tags/MongoDB/"}]},{"title":"Python(二) Python中的迭代器和生成器","slug":"Python-二-Python中的迭代器和生成器","date":"2021-01-04T07:30:56.000Z","updated":"2021-01-04T07:42:31.412Z","comments":true,"path":"2021/01/04/Python-二-Python中的迭代器和生成器/","link":"","permalink":"http://www.li2ui2.xyz/2021/01/04/Python-%E4%BA%8C-Python%E4%B8%AD%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/","excerpt":"","text":"迭代器迭代时访问集合元素的一种方式。迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个远胜于开始访问，直到所有元素被访问完结束。迭代器只能往前不会后退。迭代器的优点是占用极小的内存空间。 可迭代对象列表、元组、字符串等类型的数据可以使用for…in…的循环来依次拿到数据进行使用，这个过程称为遍历，也叫迭代。一个类中只要有__iter__方法，那么它就是一个可迭代对象；一个类中既有__iter_方法, 又有__next__方法，那么它就是一个迭代器。因此如果一个对象是一个迭代器，那么它一定可迭代；但是一个对象可迭代，它不一定是一个迭代器。 利用类的内置方法自己实现一个迭代器若for temp in xxx_obj，那么该语句实现的实际流程为： 判断当前对象xxx_obj是否为可迭代的对象：看类对象中是否创建了方法__iter__。 在第1步成立的前提下，调用方法__iter__得到xxx_obj对象的__iter__方法返回值。 __iter__方法的返回值是一个迭代器，而后调用__next__方法进行循环遍历。 下面给出自己实现的一个迭代器的代码： 123456789101112131415161718192021222324252627282930from collections import Iterablefrom collections import Iteratorclass Classmate(object): def __init__(self): self.names = list() self.current_num = 0 def add(self, name): self.names.append(name) def __iter__(self): &quot;&quot;&quot;如果想要一个对象称为一个 可以迭代的对象，即可以使用for，那么必须实现__iter__方法&quot;&quot;&quot; return self def __next__(self): if self.current_num &lt; len(self.names): ret = self.names[self.current_num] self.current_num += 1 return ret else: raise StopIterationdef main(): classmate = Classmate() classmate.add(&quot;张灿&quot;) classmate.add(&quot;里斯&quot;) classmate.add(&quot;王五&quot;) # print(&quot;判断classmate是否是可以迭代的对象：&quot;, isinstance(classmate, Iterable)) # classmate_iterator = iter(classmate) # print(&quot;判断classmate_iterator是否是迭代器：&quot;, isinstance(classmate_iterator, Iterator)) for name in classmate: print(name)if __name__ == &quot;__main__&quot;: main() 迭代器的应用斐波那契数列迭代器的实现： 12345678910111213141516171819class Fibonacci(object): def __init__(self, all_num): self.all_num = all_num self.current_num = 0 self.a = 0 self.b = 1 def __iter__(self): return self def __next__(self): if self.current_num &lt; self.all_num: ret = self.a self.a, self.b = self.b, self.a + self.b self.current_num += 1 return ret else: raise StopIterationfibo = Fibonacci(100)for num in fibo: print(num) 生成器生成器是一个特殊的迭代器。生成器表达式并不真正的创建列表，而不是返回一个生成器对象，此对象在每次计算出一个条目后，把这个条目“产生”（yield）出来。当一个序列过长，并且每次只需要获取一个元素时，应当考虑使用生成器表达式而不是列表解析，以避免占用过多的资源。 创建生成器方法1生成器创建的语法： 12(expr for iter_var in iterable)(expr for iter_var in iterable if cond_expr) 创建生成器方法21234567891011121314def create_num(all_num): a, b = 0, 1 current_num = 0 while current_num &lt; all_num: yield a # 如果一个函数中有yield语句，那么这个就不再是函数，而是一个生成器模板 a, b = b, a+b current_num += 1# 如果在调用create_num的时候，发现这个函数中有yield，那么此时不是调用函数，而是创建一个生成器对象obj = create_num(10)for num in obj: print(num)","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://www.li2ui2.xyz/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.li2ui2.xyz/tags/Python/"}]},{"title":"Python(一) Python列表简介","slug":"Python-一-Python列表简介","date":"2021-01-04T07:30:31.000Z","updated":"2021-01-04T07:42:20.997Z","comments":true,"path":"2021/01/04/Python-一-Python列表简介/","link":"","permalink":"http://www.li2ui2.xyz/2021/01/04/Python-%E4%B8%80-Python%E5%88%97%E8%A1%A8%E7%AE%80%E4%BB%8B/","excerpt":"","text":"#列表的定义&#160; &#160; &#160; &#160;列表 由一系列按特定顺序排列的元素组成。在Python中，用方括号([])来表示列表，并用逗号来分隔其中的元素。列表是有序集合，因此要访问列表的任何元素，只需将该元素的位置或索引告诉Python即可。要访问列表元素，可指出列表的名称，再指出元素的索引，并将其放在方括号内。&#160; &#160; &#160; &#160;在Python中，第一个列表元素的索引为0，而不是1。Python为访问最后一个列表元素提供了一种特殊语法：通过将索引指定为-1 ，可让Python返回最后一个列表元素。索引-2 返回倒数第二个列表元素，索引-3 返回倒数第三个列表元素，以此类推。 123#返回bicycles列表中的最后一个元素bicycles = [&#x27;trek&#x27;, &#x27;cannondale&#x27;, &#x27;redline&#x27;, &#x27;specialized&#x27;]print(bicycles[-1]) #修改、添加和删除元素##修改列表元素&#160; &#160; &#160; &#160;修改列表元素的语法与访问列表元素的语法类似。要修改列表元素，可指定列表名和要修改的元素的索引，再指定该元素的新值。 123456#输出结果为[&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]motorcycles = [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]print(motorcycles)#输出结果为[&#x27;ducati&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]motorcycles[0] = &#x27;ducati&#x27;print(motorcycles) ##在列表中添加元素1.在列表末尾添加元素 1234567#使用append()函数在列表的结尾添加函数motorcycles = [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]print(motorcycles)motorcycles.append(&#x27;ducati&#x27;)print(motorcycles)#输出结果为：[&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]# [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;, &#x27;ducati&#x27;] &#160; &#160; &#160; &#160;方法append() 让动态地创建列表易如反掌，例如，你可以先创建一个空列表，再使用一系列的append() 语句添加元素。下面来创建一个空列表，再在其中添加元素’honda’ 、’yamaha’ 和’suzuki’ ： 123456motorcycles = []motorcycles.append(&#x27;honda&#x27;)motorcycles.append(&#x27;yamaha&#x27;)motorcycles.append(&#x27;suzuki&#x27;)print(motorcycles)#输出结果：[&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;] 2.在列表中插入元素&#160; &#160; &#160; &#160;使用方法insert() 可在列表的任何位置添加新元素。下列方法insert() 在索引0 处添加空间，并将值’ducati’ 存储到这个地方。这种操作将列表中既有的每个元素都右移一个位置。同理，若要在索引1处添加空间，将列表中原先索引为1及其索引在1之后的元素都向右移一个位置。 1234motorcycles = [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]motorcycles.insert(0, &#x27;ducati&#x27;)print(motorcycles)#输出结果：[&#x27;ducati&#x27;, &#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;] ##从列表中删除元素1.使用del语句删除元素 1234567#若知道要删除的元素在列表中的位置，可使用del语句motorcycles = [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]print(motorcycles)#输出：[&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]del motorcycles[0]print(motorcycles)#输出：[&#x27;yamaha&#x27;, &#x27;suzuki&#x27;] 2.使用方法pop() 删除元素 123456789#方法pop() 可删除列表末尾的元素，并让你能够接着使用它。motorcycles = [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]print(motorcycles)#输出结果为：[&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]popped_motorcycle = motorcycles.pop()print(motorcycles)#输出结果为：[&#x27;honda&#x27;, &#x27;yamaha&#x27;]print(popped_motorcycle)#输出结果为：suzuki 12345#弹出列表中任何位置处的元素motorcycles = [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]first_owned = motorcycles.pop(0)print(first_owned)#输出结果：honda &#160; &#160; &#160; &#160;如果你不确定该使用del 语句还是pop() 方法，可以根据这个判断标准：如果你要从列表中删除一个元素，且不再以任何方式使用它，就使用del 语句；如果你要在删除元素后还能继续使用它，就使用方法pop() 。 3.根据值删除元素&#160; &#160; &#160; &#160;有时候，你不知道要从列表中删除的值所处的位置。如果你只知道要删除的元素的值，可使用方法remove() 。 123456motorcycles = [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;, &#x27;ducati&#x27;]print(motorcycles)#输出：[&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;, &#x27;ducati&#x27;]motorcycles.remove(&#x27;ducati&#x27;)print(motorcycles)#输出：[&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;] 使用remove() 从列表中删除元素时，也可接着使用它的值： 123456789motorcycles = [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;, &#x27;ducati&#x27;]print(motorcycles)#输出:[&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;, &#x27;ducati&#x27;]too_expensive = &#x27;ducati&#x27;motorcycles.remove(too_expensive)print(motorcycles)#输出：[&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]print(&quot;\\nA &quot; + too_expensive.title() + &quot; is too expensive for me.&quot;)#输出：A Ducati is too expensive for me. 注意 方法remove() 只删除第一个指定的值。如果要删除的值可能在列表中出现多次，就需要使用循环来判断是否删除了所有这样的值。 #组织列表 1.使用方法sort() 对列表进行永久性排序 1234cars = [&#x27;bmw&#x27;, &#x27;audi&#x27;, &#x27;toyota&#x27;, &#x27;subaru&#x27;]cars.sort()print(cars)#输出：[&#x27;audi&#x27;, &#x27;bmw&#x27;, &#x27;subaru&#x27;, &#x27;toyota&#x27;] &#160; &#160; &#160; &#160;方法sort() 永久性地修改了列表元素的排列顺序。以上代码让汽车是按字母顺序排列的，再也无法恢复到原来的排列顺序。还可以按与字母顺序相反的顺序排列列表元素，为此，只需向sort() 方法传递参数reverse=True 。下面的示例将汽车列表按与字母顺序相反的顺序排列： 1234cars = [&#x27;bmw&#x27;, &#x27;audi&#x27;, &#x27;toyota&#x27;, &#x27;subaru&#x27;]cars.sort(reverse=True)print(cars)#输出：[&#x27;toyota&#x27;, &#x27;subaru&#x27;, &#x27;bmw&#x27;, &#x27;audi&#x27;] 2.使用函数sorted() 对列表进行临时排序&#160; &#160; &#160; &#160;要保留列表元素原来的排列顺序，同时以特定的顺序呈现它们，可使用函数sorted() 。函数sorted() 让你能够按特定顺序显示列表元素，同时不影响它们在列表中的原始排列顺序。 3.列表的其它操作方法reverse()、函数len() 的使用： 1234567#要反转列表元素的排列顺序，可使用方法reverse()cars = [&#x27;bmw&#x27;, &#x27;audi&#x27;, &#x27;toyota&#x27;, &#x27;subaru&#x27;]print(cars)#输出：[&#x27;bmw&#x27;, &#x27;audi&#x27;, &#x27;toyota&#x27;, &#x27;subaru&#x27;]cars.reverse()print(cars)#输出：[&#x27;subaru&#x27;, &#x27;toyota&#x27;, &#x27;audi&#x27;, &#x27;bmw&#x27;] 1234#使用函数len() 可快速获悉列表的长度。cars = [&#x27;bmw&#x27;, &#x27;audi&#x27;, &#x27;toyota&#x27;, &#x27;subaru&#x27;]print(len(cars))#输出：4 注意 笔者沉痛的教训，在编程学习的过程中，一定要严谨！！区分方法和函数的概念！！方法可供对象调用，而函数是需要引入参数才能使用的。例如以下代码报错，即将方法和函数之间错误使用了。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://www.li2ui2.xyz/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.li2ui2.xyz/tags/Python/"}]},{"title":"计算机网络基础知识点回顾","slug":"计算机网络基础知识点回顾","date":"2021-01-04T07:26:59.000Z","updated":"2021-01-04T07:29:38.039Z","comments":true,"path":"2021/01/04/计算机网络基础知识点回顾/","link":"","permalink":"http://www.li2ui2.xyz/2021/01/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE/","excerpt":"","text":"概述Internet和internet的区别 以小写字母 i 开始的 internet（互联网或互连网）是一个通用名词，它泛指由多个计算机网络互连而成的网络 以大写字母I开始的的 Internet（因特网）则是一个专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定计算机网络，它采用 TCP/IP 协议族作为通信的规则，且其前身是美国的 ARPANET。 ISP因特网服务提供者 Intenet的组成由边缘部分和核心部分组成 边缘部分由所有连接在因特网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。 计算机之间的两种通信方式： 客户服务器方式（Client/Server，C/S 方式）；对等方式（Peer-to-Peer，P2P 方式）。 核心部分由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的(提供连通性和交换)。在网络核心部分起特殊作用的是路由器(router)。路由器是实现分组交换(packet switching)的关键构件，其任务是转发收到的分组。 NT: 与交换机的区别：“交换”(switching)的含义就是转接，从通信资源的分配角度来看，“交换”就是按照某种方式动态地分配传输线路的资源。使用交换机来完成全网的交换任务。分组交换：分组交换网以“分组”作为数据传输单元，依次把各分组发送到接收端。路由器处理分组的过程是： 把收到的分组先放入缓存（暂时存储）；查找转发表，找出到某个目的地址应从哪个端口转发；把分组送到适当的端口转发出去。主机和路由器的不同作用： 主机是为用户进行信息处理的，并向网络发送分组，从网络接收分组；路由器对分组进行存储转发，最后把分组交付目的主机。三种交换的比较： 电路交换、报文交换、分组交换 计算机网络的性能指标 速率： 速率即数据率(data rate)或比特率(bit rate)，速率的单位是 b/s，或kb/s, Mb/s, Gb/s 等； 带宽： 数字信道所能传送的“最高数据率”，单位是“比特每秒”，或 b/s (bit/s)； 吞吐量(throughput): 表示在单位时间内通过某个网络（或信道、接口）的数据量; 传输时延（发送时延 ）: 发送数据时，数据块从结点进入到传输媒体所需要的时间。 时延带宽积： 以比特为单位的链路长度，其值等于传播时延和带宽的乘积。 利用率： 信道利用率指出某信道有百分之几的时间是被利用的（有数据通过），完全空闲的信道的利用率是零。网络利用率则是全网络的信道利用率的加权平均值。 TCP/IP的体系结构 链路层： 主要工作就是对电信号进行分组，并形成有意义的数据帧，然后以广播的形式通过物理介质发送给接收方。同时，定义了主机的身份(MAC地址)。该层的协议有PPP 网络层： 定义网络地址，区分网段，子网内MAC寻址，对于不同的数据包进行路由协议，包括IP协议、ARP协议以及各种路由协议。该层的协议有IP、ICMP、IGMP、ARP以及RARP等 传输层： 定义端口，标识应用层序身份，实现端口到端口的通信，TCP协议可以保证数据传输的可靠性。该层的协议有TCP、UDP等 应用层： 定义数据格式并按照对应的格式解读数据。该层的协议有HTTP、FTP、SMTP等 无线网络无线局域网无线局域网的基本组成一个基本服务集 BSS 包括一个基站和若干个移动站，所有的站在本 BSS 以内都可以直接通信，但在和本 BSS 以外的站通信时 ，都要通过本 BSS 的基站。基本服务集内的基站叫做接入点 AP (Access Point)其作用和网桥相似。当网络管理员安装 AP 时，必须为该 AP 分配一个不超过 32 字节的服务集标识符 SSID 和一个信道。 一个基本服务集可以是孤立的，也可通过接入点 AP连接到一个主干分配系统 DS (Distribution System)，然后再接入到另一个基本服务集，构成扩展的服务集ESS (Extended Service Set)。ESS 还可通过叫做门户(portal)为无线用户提供到非 802.11 无线局域网（例如，到有线连接的因特网）的接入。门户的作用就相当于一个网桥。 移动站 A 从某一个基本服务集漫游到另一个基本服务集（到 A 的位置），仍可保持与另一个移动站 B 进行通信。 与接入点AP建立关联(association)一个移动站若要加入到一个基本服务集 BSS，就必须先选择一个接入点 AP，并与此接入点建立关联。建立关联就表示这个移动站加入了选定的 AP 所属的子网，并和这个 AP 之间创建了一个虚拟线路。只有关联的 AP 才向这个移动站发送数据帧，而这个移动站也只有通过关联的 AP 才能向其他站点发送数据帧。 热点(Hot Spot)现在许多地方，如办公室、机场、快餐店、旅馆、购物中心等都能够向公众提供有偿或无偿接入 Wi-Fi 的服务。这样的地点就叫做热点。由许多热点和 AP 连接起来的区域叫做热区(hot zone)。热点也就是公众无线入网点。现在也出现了无线因特网服务提供者 WISP (Wireless Internet Service Provider)这一名词。用户可以通过无线信道接入到 WISP，然后再经过无线信道接入到因特网。 移动自组网络移动自组网络又称自组网络(as hoc network)，自组网络是没有固定基础设施（即没有 AP）的无线局域网。这种网络由一些处于平等状态的移动站之间相互通信组成的临时网络。 移动自组网和移动IP并不相同移动 IP 技术使漫游的主机可以用多种方式连接到因特网。移动 IP 的核心网络功能仍然是基于在固定互联网中一直在使用的各种路由选择协议。移动自组网络是将移动性扩展到无线领域中的自治系统，它具有自己特定的路由选择协议，并且可以不和因特网相连。 几种不同的接入 固定接入(fixed access)：在作为网络用户期间，用户设置的地理位置保持不变。 移动接入(mobility access)：用户设置能够以车辆速度移动时进行网络通信。当发生切换时，通信仍然是连续的。 便携接入(portable access)：在受限的网络覆盖面积中，用户设备能够在以步行速度移动时进行网络通信，提供有限的切换能力。 游牧接入(nomadic access)：用户设备的地理位置至少在进行网络通信时保持不变。如用户设备移动了位置，则再次进行通信时可能还要寻找最佳的基站 无线城域网WIMAX服务范围示意图","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.li2ui2.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.li2ui2.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"Mininet-WIFI(二) POX控制器+Gephi可视化软件来定义Mininet-wifi网络拓扑结构","slug":"Mininet-WIFI-二-POX控制器-Gephi可视化软件来定义Mininet-wifi网络拓扑结构","date":"2021-01-04T07:21:11.000Z","updated":"2021-01-04T07:23:23.037Z","comments":true,"path":"2021/01/04/Mininet-WIFI-二-POX控制器-Gephi可视化软件来定义Mininet-wifi网络拓扑结构/","link":"","permalink":"http://www.li2ui2.xyz/2021/01/04/Mininet-WIFI-%E4%BA%8C-POX%E6%8E%A7%E5%88%B6%E5%99%A8-Gephi%E5%8F%AF%E8%A7%86%E5%8C%96%E8%BD%AF%E4%BB%B6%E6%9D%A5%E5%AE%9A%E4%B9%89Mininet-wifi%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84/","excerpt":"","text":"引言积跬步以至千里，积怠情以至深渊。 在POX SDN控制器包括将网络拓扑的数据发送到数据Gephi可视化平台，可显示节点和表示网络拓扑结构链接的曲线图。 具体操作步骤启动POX关于POX的安装可以参考作者的前一篇博客。首先打开第一个Terminal，开始运行POX SDN控制器。终端切换到pox目录下，执行如下命令启动POX： terminal1sudo .&#x2F;pox.py forwarding.l2_learning openflow.discovery misc.gephi_topo openflow.spanning_tree --no-flood --hold-down host_tracker info.packet_dump samples.pretty_log log.level --DEBUG 其中每个组件的功能如下： 1.forwarding.l2_learning在l2_learning组件使OpenFlow交换机的作用类似于以太网学习交换机。它学习以太网MAC地址，并匹配包头中的所有字段，因此可以为每对MAC地址在网络中安装多个流。例如，不同的TCP连接将导致安装不同的流。 2.openflow.discovery该组件使用发送到OpenFlow交换机和从OpenFlow交换机接收到的LLDP消息来发现网络拓扑。它还可以检测网络链接何时上升或下降。 3.misc.gephi_topo当POX检测到网络拓扑结构的变化时，Gephi_Topo组件将从POX流更新到Gephi图形可视化平台。该组件有效地创建了一个到Gephi图形可视化平台的北向接口。它将实时数据流到Gephi将侦听的IP地址和端口，格式是Gephi可以解释的。 4.openflow.spanning_tree ‐‐no-flood ‐‐hold-down在网络拓扑包含循环的情况下，需要生成树组件。它与OpenFlow Discovery组件一起构建网络拓扑视图，并通过禁用不在树中的交换机端口上的泛洪来构建一个生成树。选项no-flood和hold-down用于确保在组件创建生成树之前网络中没有数据包被淹没。生成树组件将响应网络拓扑结构中的更改。如果一个链接断开，并且存在一个备用链接，那么它可以通过创建一个新树来维护网络中的连接性，该树支持对连接到备用链接的端口进行洪泛。 5.host_tracker主机跟踪器组件试图跟踪网络中的主机。主机跟踪器检查POX接收到的消息，并学习网络中主机的MAC和IP。主机跟踪器将在我们的例子中工作，但它依赖于数据包到达控制器。网络中的包转发必须是反应性的，因此我们需要使用forward .l2_learning这样的转发组件。 6.info.packet_dump包转储组件将在日志控制台显示POX从交换机接收到的数据包的信息。这将帮助我们了解交换机如何在不运行tcpdump的情况下与POX控制器交互。 7.log.level ‐‐DEBUG该组件允许POX用户指定他们将在POX生成的日志信息中看到的详细信息的数量，最详细的级别是DEGUG。 8.samples.pretty_logPretty Log组件将日志消息格式化为自定义日志格式，以便在POX控制台上提供有吸引力且可读的日志输出。 Gephi的启动打开一个新的Terminal，启动Gephi： terminal12cd ~&#x2F;gephi&#x2F;binsudo .&#x2F;gephi 在Gephi中安装好Graph Streaming插件，安装好后，配置流媒体服务器设置。该Gephi.Topo组件使用TCP端口8282。点击设置按钮，并设置端口为8282和清除SSL复选框。 在Gephi用户界面中，转到流选项卡，然后单击绿色的“添加”符号。一个连接到信息流将出现配置窗口显示。输入Gephi将连接的URL。在我们的例子中，Gephi和POC = X控制器都在同一台机器上运行，因此网址的IP地址是环回地址，输入侧可以127.0.0.1或本地主机。Gephi_Topo组件使用的端口号是8282。所以输入网址：http://localhost:8282。 启动Mininet-WiFi网络拓扑启动脚本","categories":[{"name":"软件定义网络","slug":"软件定义网络","permalink":"http://www.li2ui2.xyz/categories/%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"Mininet-WiFi","slug":"Mininet-WiFi","permalink":"http://www.li2ui2.xyz/tags/Mininet-WiFi/"},{"name":"POX控制器","slug":"POX控制器","permalink":"http://www.li2ui2.xyz/tags/POX%E6%8E%A7%E5%88%B6%E5%99%A8/"},{"name":"Gephi可视化平台","slug":"Gephi可视化平台","permalink":"http://www.li2ui2.xyz/tags/Gephi%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B3%E5%8F%B0/"}]},{"title":"Mininet-WIFI(一) Mininet学习笔记之基本操作","slug":"Mininet-WIFI-一-Mininet学习笔记之基本操作","date":"2021-01-04T07:13:38.000Z","updated":"2021-01-04T07:20:16.388Z","comments":true,"path":"2021/01/04/Mininet-WIFI-一-Mininet学习笔记之基本操作/","link":"","permalink":"http://www.li2ui2.xyz/2021/01/04/Mininet-WIFI-%E4%B8%80-Mininet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","excerpt":"","text":"引言积跬步以至千里，积怠情以至深渊。 Mininet是一个轻量级软件定义网络研发和测试平台，主要特性包括支持 Openflow、OpenvSwitch 等软定义网络部件；方便多人协同开发；支持系统级的还原测试；支持复杂拓扑、自定义拓扑；提供 Python API很好的硬件移植性（Linux 兼容），结果有更好的说服力；高扩展性，支持超过 4096 台主机的网络结构。Mininet可以模拟真实网络， 主要是用到了Linux 内核的namespace机制，通俗来说，namespace机制就是可以给模拟网络中的每一个虚拟设备分一个空间，各个虚拟设备之间彼此没有关系（看不到对方，但是可以连接起来）。namespace机制按照datapath的运行权限不通，分为kernel datapath和userspace datapath两种。 作为Mininet入门选手，特此分享心得笔记。不对之处， 还望批评指正！ 创建网络启动Mininet，创建默认的网络拓扑图命令为sudo mn，该默认拓扑图结构如下图所示，拥有一台控制节点(controller)、一台交换机(Switch)、两台主机(host)的网络，可以通过wireshark进行观测。 查看网络基本信息CLI的交互式操作 # 查看全部节点 mininet&gt; nodes # 查看链路信息 mininet&gt; net # 输出各节点信息 mininet&gt; dump 对节点进行单独操作如果想要对某个节点的虚拟机单独进行命令操作，也十分简单，命令格式为 node cmd。 例如查看交换机 s1 上的网络信息，我们只需要在执行的 ifconfig 命令前加上 s1 主机标志即可，即 s1 ifconfig，同样，如果我们想用 ping 3 个包的方法来测试 h2 跟 h3 之间连通情况，只需要执行 h2 ping -c 3 h3 即可。 全网络互ping命令是 pingall 常规操作快捷测试除了 CLI 的交互方式之外，Mininet 还提供了更方便的自动执行的快捷测试方式，其格式为 sudo mn –test cmd，即可自动启动并执行 cmd 操作，完成后自动退出。sudo mn –test pingpair，可以直接对主机连通性进行测试，sudo mn –test iperf，启动后直接进行性能测试。用这种方式很方便直接得到实验结果。 自定义拓扑Mininet 提供了 Python API，可以用来方便的自定义拓扑结构。 在 mininet/custom 目录下给出了几个例子。例如在文件中定义了一个 mytopo，则可以通过 –topo 选项来指定使用这一拓扑，命令为 sudo mn --custom ~/mininet/custom/topo-2sw-2host.py --topo mytopo --test pingall 使用Xtermsudo mn -x 或者再进入mn CLI之后，用如下命令启动 xterm s1 链路操作在 Mininet CLI 中，使用 link 命令，禁用或启用某条链路，格式为 link node1 node2 up/down 指定交换机跟控制器的类型通过 –switch 选项跟 –controller 选项可以分别指定采用哪种类型的交换机跟控制器。下面，以更换使用pox控制器为例进行介绍： POX是由NOX演变而来，其底层模块由C++实现，上层应用可以用C++或Python编写，它的核心作用是提供快速开发网络控制软件原型的平台。POX和OpenFlow交换机进行交互，可以用于软件定义网络这个新兴学科的基础研究，比如探索和原型分布、SDN调试、网络虚拟化、控制器设计和编程模型。 1.POX系统配置并启动POX 修改监听端口 POX的监听端口默认是6633，修改监听端口的方式有以下两种： (1)每次启动POX时指定监听端口，如指定的端口为6636，则在命令行后添加： openflow.of_01 --port=6636 (2)修改控制器的默认端口方法修改/pox/openflow/of_01.py文件，如指定的端口为6636，则将文件中所有的port=6633改为port=6636。 配置Web界面端口POX支持GUI，通过POXDesk等工具实现，本小节介绍如何配置POX的GUI。具体操作如下: (1)获取POXDesk进入POX主目录下面的ext目录 cd ./pox/ext git clone https://github.com/MurphyMc/poxdesk (2)获取qooxdoo下载qooxdoo代码压缩包，然后把解压后文件夹名字改成qx cd poxdesk wget http://downloads.sourceforge.net/qooxdoo/qooxdoo-2.0.2-sdk.zip unzip qooxdoo-2.0.2-sdk.zip mv qooxdoo-2.0.2-sdk qx (3)初始化poxdesk进入poxdesk目录，执行命令./generate.py，然后再进入POX主目录 cd poxdesk ./generate.py cd ../../.. (4)启动POX若在启动POX报错地址已被占用，则使用ps -fA | grep python来查看当前正在调用POX的Python进程，找到进程编号，杀死即可。 ./pox.py samples.pretty_log web messenger messenger.log_service messenger.ajax_transport openflow.of_service poxdesk openflow.discovery poxdesk.tinytopo py (5)访问Web用浏览器访问http://pox-ip:8000/poxdesk，默认端口8000。 2.启动mininet在启动POX后，打开另一个cmd，并启动mininet，并且连接到远程ip = 127.0.0.1, port = 6633的pox控制器。 sudo mn --controller=remote,ip=127.0.0.1,port=6633 常用命令总结 其他命令执行 sudo mn -c 会进行清理配置操作，适合故障后恢复。执行 exit 会退出 Mininet 的 CLI，同时给出运行时间统计。 Mininet的高级功能使用下面，将通过一个具体管理 Openflow switch 的例子来介绍一些比较高级的命令。 首先，启动 Mininet，执行 sudo mn --topo single,3 --mac --switch ovsk --controller remote 生成一个小的网络，三台主机连到一台交换机上，交换机为 OpenvSwitch 交换机，指定 remote 类型控制器（默认为本地）。 dpctldpctl 程序是一个命令行工具用来检测和管理 OpenFlow 数据通路，它能够显示当前的状态数据通路，包括功能配置和表中的条目，以及合适使用 OpenFlow 的内核模块，可以用来添加，删除，修改和监视 datapaths。 1.查看到交换机的端口等基本情况，其中 tcp 端口 6634 是默认的交换机监听端口 s1 dpctl show tcp:127.0.0.1:6634 2.查看流表信息： dpctl dump-flows tcp:127.0.0.1:6634 此时，流表为空，执行 h1 ping h2 无法得到响应。因此我们需要通过 dpctl 手动添加流表项，实现转发。 3.手动添加流表项： dpctl add-flow tcp:127.0.0.1:6634 in_port=1,actions=output:2 dpctl add-flow tcp:127.0.0.1:6634 in_port=2,actions=output:1 dpctl dump-flows tcp:127.0.0.1:6634 此时查看流表可以看到新的转发信息，同时可以在 h1 和 h2 之间可以相互连通。 4.dpctl 其他常用操作创建 datapath 编号为 0 dpctl adddp n1:0 增加两个网络设备到新的 datapath dpctl adddp n1:0 eth0 dpctl adddp n1:0 eth1 检测数据通路接收的流量 dpctl monitor n1:0 在数据通路中删除网络设备 dpctl delif nl:0 eth0 Mininet代码结构 bin/mn：主运行文件，安装后执行 mn 即调用的本程序，是 Python 程序。 mnexec.c ：执行一些快速命令，比如关闭文件描述符等，是 C 程序，编译后生成二进制文件 mnexec 被 Python 库调用。 核心代码基本都在 mininet/ 子目录下。 CONTRIBUTORS：作者信息；README.md：主说明文件；doc/doxygen.cfg：执行doxygen生成文档时的配置文件。 custom/ ：目录下可以放一些用户自定义的 Python 文件，比如自定义的拓扑类等。 mininet/test/ ：目录下是一些测试的例子。 util/：目录下是一些辅助文件，包括安装脚本、文档辅助生成文件等。 整体逻辑功能Mininet 作为一个基于 Python 的网络模拟工具，可以分为两大部分：Python库和运行文件。前者提供对网络中元素进行抽象和实现，例如定义主机类来表示网络中的一台主机。后者则基于这些库来完成各种自定义的模拟过程。一个典型的场景如下图所示。 总结Mininet是一个网络仿真器，或者更确切地说是一个 网络仿真编排系统。它在单个Linux内核上运行一组终端主机，交换机，路由器和链接。 它使用轻量级虚拟化使单个系统看起来像一个完整的网络，运行相同的内核，系统和用户代码。Mininet主机的行为就像真机一样; 你可以ssh进去（如果你开始 sshd并将网络桥接到您的主机上）并运行任意程序（包括安装在底层Linux系统上的任何程序。）您运行的程序可以通过看似真正的以太网接口发送数据包，具有给定的链接速度和延迟。数据包通过具有给定数量的排队的真实以太网交换机，路由器或中间件进行处理。当两个程序（如 iperf客户端和服务器）通过Mininet进行通信时，测量的性能应该与两个（较慢的）本机的性能相匹配。 简而言之，Mininet的虚拟主机，交换机，链接和控制器是真实的 - 它们只是使用软件而不是硬件创建的 - 并且大多数情况下它们的行为类似于分立的硬件元素。通常可以创建类似于硬件网络的Mininet网络，或类似于Mininet网络的硬件网络，并在任一平台上运行相同的二进制代码和应用程​​序。","categories":[{"name":"软件定义网络","slug":"软件定义网络","permalink":"http://www.li2ui2.xyz/categories/%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"POX控制器","slug":"POX控制器","permalink":"http://www.li2ui2.xyz/tags/POX%E6%8E%A7%E5%88%B6%E5%99%A8/"},{"name":"Mininet","slug":"Mininet","permalink":"http://www.li2ui2.xyz/tags/Mininet/"},{"name":"网络仿真器","slug":"网络仿真器","permalink":"http://www.li2ui2.xyz/tags/%E7%BD%91%E7%BB%9C%E4%BB%BF%E7%9C%9F%E5%99%A8/"}]},{"title":"SDN(四) RYU控制器下ping命令的具体执行过程","slug":"SDN-四-RYU控制器下ping命令的具体执行过程","date":"2020-11-20T06:00:44.000Z","updated":"2020-11-20T06:13:27.096Z","comments":true,"path":"2020/11/20/SDN-四-RYU控制器下ping命令的具体执行过程/","link":"","permalink":"http://www.li2ui2.xyz/2020/11/20/SDN-%E5%9B%9B-RYU%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%8Bping%E5%91%BD%E4%BB%A4%E7%9A%84%E5%85%B7%E4%BD%93%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/","excerpt":"","text":"1 引言积跬步以至千里，积怠情以至深渊。 本人将在此文档中介绍在SDN网络中ping命令的具体执行过程。若有不足，望读者能在共同学习的同时，批评指正。 2 ping命令在传统网路中的执行过程首先，如果主机A，要去ping主机B，那么主机A，就要封装二层报文，他会先查自己的MAC地址表，如果没有B的MAC地址，就会向外发送一个ARP广播包，具体ARP报文格式请自行查阅。交换机会收到这个报文后，交换机有学习MAC地址的功能，所以他会检索自己有没有保存主机B的MAC地址，如果有，就返回给主机A，如果没有，就会向所有端口发送ARP广播，其它主机收到后，发现不是在找自己，就纷纷丢弃了该报文，不去理会。直到主机B收到了报文后，就立即响应，我的MAC地址是多少，同时学到主机A的MAC地址，并按同样的ARP报文格式返回给主机A。主机A学到了主机B的MAC地址，就把这个MAC地址封装到ICMP协议的二层报文中向主机B发送。即在ping命令过程中，主要执行两个过程，当没有MAC地址表的时候，先进行广播，广播后得到MAC地址，则进行发送ICMP过程。 3 ping命令在SDN网路中的执行过程3.1 ARP交互当H1 ping H2时，H1的ARP 缓存表为空，因此会产生APR Request数据包发送至交换机S1，当交换机S1收到ARP Request数据包时，对初始的流表项（当控制器链接交换机后，会对交换机下发初始流表，且此流表优先级最低，当数据包没有对应的流表项进行匹配时，匹配此流表，将其发送至控制器）进行匹配，并通过Packet-in方式发送给控制器。 控制器对接收到的packet-in数据包在mac-to-port中查找是否存在对应的ＭＡＣ地址和端口。若不存在，则发送packet-out,对除源端口之外的所有端口进行泛洪处理，并将Ｈ１的对应ＭＡＣ地址和端口信息存储到mac-to-port 表中，这个过程控制器并不下发流表。 当H2收到泛洪信息后，将会回复一条ARP Reply，因H2中也不存在MAC地址缓存表，且此时控制器没有下发流表，所以ARP Reply也会执行packet-in发送到控制器，在控制器的mac-to-port 中存在了H1的信息，所以控制器会通过packet-out直接发送到端口1，同时下发关于入端口2，目的地址H1，输出端口1的流表项，并且记录H2相应的信息到mac-to-port表中。 3.2 ICMP交互H1收到H2的回应后，发送ICMP报文，但交换机中并不存在流表项来处理ICMP数据包，因此会用同样的方式将报文发送到控制器，但此时，控制器中的mac-to-port表中存在了H2的相应信息，所以通过packet-out直接发送到端口，并同时下发关于入端口为1，目的地址H2，输出端口2的流表项，增加交换机流表中的流表项。 3.3 总体交互","categories":[{"name":"软件定义网络","slug":"软件定义网络","permalink":"http://www.li2ui2.xyz/categories/%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"软件定义网络","slug":"软件定义网络","permalink":"http://www.li2ui2.xyz/tags/%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C/"},{"name":"ping命令原理","slug":"ping命令原理","permalink":"http://www.li2ui2.xyz/tags/ping%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86/"},{"name":"icmp协议","slug":"icmp协议","permalink":"http://www.li2ui2.xyz/tags/icmp%E5%8D%8F%E8%AE%AE/"},{"name":"arp协议","slug":"arp协议","permalink":"http://www.li2ui2.xyz/tags/arp%E5%8D%8F%E8%AE%AE/"}]},{"title":"SDN(五) Netgear R6220从刷机到配置 OpenvSwitch交换机","slug":"SDN-五-Netgear-R6220从刷机到配置-OpenvSwitch交换机","date":"2020-11-20T05:58:06.000Z","updated":"2020-11-20T06:08:26.948Z","comments":true,"path":"2020/11/20/SDN-五-Netgear-R6220从刷机到配置-OpenvSwitch交换机/","link":"","permalink":"http://www.li2ui2.xyz/2020/11/20/SDN-%E4%BA%94-Netgear-R6220%E4%BB%8E%E5%88%B7%E6%9C%BA%E5%88%B0%E9%85%8D%E7%BD%AE-OpenvSwitch%E4%BA%A4%E6%8D%A2%E6%9C%BA/","excerpt":"","text":"1 引言积跬步以至千里，积怠情以至深渊。 本文将介绍在Netgear R6220路由器上进行基于OpenVswitch的openflow实验。路由器是刷了编译了OpenvSwitch的OpenWRT固件的，具体可参考刷机教程。本文主要以R6220为例介绍从刷机到配置 OpenvSwitch交换机的整个过程。 2 Netgear R6220刷机 收到原厂Netgear R6220路由器后，用一根网线接上笔记本网口和路由器LAN口。 打开浏览器，输入192.168.1.1，进入路由器原厂管理界面，设置好路由器的管理密码。 在浏览器中输入网址http://192.168.1.1/setup.cgi?todo=debug，并回车，开启路由器的telnet功能。 Windows系统下打开本地命令提示符（其他系统也可以），输入telnet 192.168.1.1，终端登录路由器，用户名为admin，密码为上边设置的。 进入后，将带有编译好的固件（编译了OpenVSwitch的OpenWRT固件，可以到我的云盘中提取，链接：https://pan.baidu.com/s/1Y3tq0nsxfi5_wX7FO4xXCw ，提取码：ew7d）的U盘插入路由器USB口。 而后，进入…./ramips/mt7621，开始刷入固件，操作步骤如下截图所示。 NT：一定要先刷kernel，再刷rootfs。同时在刷固件过程中一定不要插拔网线，否则变砖！！ 刷完固件重启路由器，耐心等待重新获取得到网卡信息，首先重新以网页方式登录路由器新固件OpenWRT的管理界面（方法为在网页中输入192.168.1.1），进入网页后，只设置密码而不做其他多余操作（例如进入网络接口界面，因为一旦进入就会默认生成一次配置，会与之后的终端配置造成冲突），否则影响最终的配置，导致路由器变砖。 紧接着，ssh进入OprnWRT系统，用户名为root，密码为上一步设置的密码。 进入/etc/config下配置network文件和wireless文件，文件的配置需要根据物理设备的网卡信息进行正确配置，因此首先摸清Netgear R6220的网络配置信息尤为关键，否则将导致路由器变砖，或者无法配置好网桥信息。以下部分，第3节主要介绍物理设备网络信息，第4节主要介绍具体的network文件和wireless文件配置，第5节主要介绍针对第4节的配置信息进行的网桥搭建过程。 NT：刷机变砖请参考本人博客Netgear救砖教程。 3 Netgear R6220网络配置信息介绍 4 Netgear R6220路由器的网络文件配置4.1 network文件配置关于配置文件中的配置代码对应功能介绍，请参考本人博客SDN(二)，本人对于network文件的配置如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778# 本地回环地址config interface &#x27;loopback&#x27; option ifname &#x27;lo&#x27; option proto &#x27;static&#x27; option ipaddr &#x27;127.0.0.1&#x27; option netmask &#x27;255.0.0.0&#x27;config globals &#x27;globals&#x27; option ula_prefix &#x27;fd22:7199:e878::/48&#x27;# 划分lan口config interface &#x27;lan&#x27; # 将LAN1配置成内网地址 option type &#x27;bridge&#x27; option ifname &#x27;eth0.3&#x27; option proto &#x27;static&#x27; option ipaddr &#x27;192.168.3.1&#x27; option netmask &#x27;255.255.255.0&#x27; option ip6assign &#x27;60&#x27;config device &#x27;lan_dev&#x27; option name &#x27;eth0.3&#x27; option macaddr &#x27;8c:3b:ad:e4:5a:b1&#x27;config interface &#x27;wan_controller&#x27; # wan口配置成控制器地址，该IP地址为运行控制器的主机的网关IP地址 option ifname &#x27;eth0.4&#x27; option proto &#x27;static&#x27; option ipaddr &#x27;10.12.34.248&#x27; # 必须与LAN口在不同网段 option netmask &#x27;255.255.255.0&#x27;config device &#x27;wan_dev&#x27; option name &#x27;eth0.4&#x27; option macaddr &#x27;8c:3b:ad:e4:5a:b0&#x27;config interface &#x27;wan6&#x27; option ifname &#x27;eth0.4&#x27; option proto &#x27;dhcpv6&#x27;config interface &#x27;lan2&#x27; # 其余LAN口不分配IP地址，作为openflow端口，供OpenVswitch中网桥的端口映射 option ifname &#x27;eth0.2&#x27; option proto &#x27;static&#x27;config interface &#x27;lan3&#x27; option ifname &#x27;eth0.1&#x27; option proto &#x27;static&#x27;config interface &#x27;lan4&#x27; option ifname &#x27;eth0.0&#x27; option proto &#x27;static&#x27; config switch # swith，用于R6220的四个LAN口的IP映射 option name &#x27;switch0&#x27; option reset &#x27;1&#x27; option enable_vlan &#x27;1&#x27; config switch_vlan # 划分vlan option device &#x27;switch0&#x27; option vlan &#x27;0&#x27; option ports &#x27;0 6t&#x27; config switch_vlan option device &#x27;switch0&#x27; option vlan &#x27;1&#x27; option ports &#x27;1 6t&#x27; config switch_vlan option device &#x27;switch0&#x27; option vlan &#x27;2&#x27; option ports &#x27;2 6t&#x27; config switch_vlan option device &#x27;switch0&#x27; option vlan &#x27;3&#x27; option ports &#x27;3 6t&#x27; config switch_vlan option device &#x27;switch0&#x27; option vlan &#x27;4&#x27; option ports &#x27;4 6t&#x27; 配置完成后，输入/etc/init.d/network restart进行网络重启。 4.2 wireless文件配置在配置好network后，可参照如下代码进行无线设置（也可以进入网页，直接针对无线进行可视化配置），关于Neatgear中的wireless文件本人配置如下，此时无线和LAN1分配在了同一个网段，因此wifi连接路由器也可以进入内网配置。 123456789101112131415161718192021222324252627282930313233config wifi-device &#x27;radio0&#x27; option type &#x27;mac80211&#x27; option channel &#x27;11&#x27; option hwmode &#x27;11g&#x27; option path &#x27;pci0000:00/0000:00:01.0/0000:02:00.0&#x27; option htmode &#x27;HT20&#x27; option country &#x27;00&#x27; option legacy_rates &#x27;1&#x27;config wifi-iface &#x27;default_radio0&#x27; option device &#x27;radio0&#x27; option network &#x27;lan&#x27; # 当要将wlan0配置成无线接口时，不需要分配网段 option mode &#x27;ap&#x27; option encryption &#x27;none&#x27; option ssid &#x27;OpenWrt2_0&#x27; option ifname wlan0 # 这个wifi接口名称的设置相当重要，需要作为ovs中网桥设置的接口config wifi-device &#x27;radio1&#x27; option type &#x27;mac80211&#x27; option channel &#x27;36&#x27; option hwmode &#x27;11a&#x27; option path &#x27;pci0000:00/0000:00:00.0/0000:01:00.0&#x27; option htmode &#x27;VHT80&#x27; option country &#x27;00&#x27; option legacy_rates &#x27;1&#x27;config wifi-iface &#x27;default_radio1&#x27; option device &#x27;radio1&#x27; option mode &#x27;ap&#x27; option encryption &#x27;none&#x27; option ssid &#x27;OpenWrt2_1&#x27; option ifname wlan1 # 这个wifi接口名称的设置相当重要，需要作为ovs中网桥设置的接口 配置完成后，再次输入/etc/init.d/network restart进行网络重启。 5 Netgear R6220中OpenVswitch的网桥创建及配置针对network中的配置，网桥的对应配置如下: 12345678910ovs-vsctl add-br br0 # 创建网桥ovs-vsctl set-fail-mode br0 secure|standalone # 网桥默认模式为standlone，这里将其设置成secure模式# standlone: 若OVS交换机超过3次无法正常连接到OpenFlow控制器，OVS交换机会自己负责建立流表，与常见的L2交换机类似进行工作。一旦网络连接恢复，OVS会再次切换到使用控制器进行流表管理；# secure: 在该模式下，若OVS无法正常连接到OPenFlow控制器，OVS会不停的尝试与控制器重新建立连接，而不会自己负责建立流表。ovs-vsctl add-port br0 eth0.0 -- set Interface eth0.0 ofport_request=4 # 添加端口，并固定端口编号为4，否则每次随机生成。ovs-vsctl add-port br0 eth0.1 -- set Interface eth0.1 ofport_request=3 # 由于eth0.3已配置成OpenWRT内网接入地址，因此无法添加eth0.3ovs-vsctl add-port br0 eth0.2 -- set Interface eth0.2 ofport_request=2ovs-vsctl add-port br0 wlan0 -- set Interface wlan0 ofport_request=5 #添加2.4G频段无线接口ovs-vsctl add-port br0 wlan1 -- set Interface wlan1 ofport_request=6 #添加5.0G频段无线接口ovs-vsctl set-controller br0 tcp:10.12.34.180:6653 tcp:10.12.34.180:6654 # 添加多控制器，该IP地址为运行控制器的主机的IP地址 在对网桥进行以上配置后，为运行控制器的主机添加对应网络配置（IP为10.0.30.1/24，网关为10.0.30.254），并运行控制器代码。Netgear R6220路由器即可连接上该控制器。 此外，其他关于网桥的相关操作如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354ovs-vsctl show # 查看网桥状态ovs-vsctl del-br br0 # 删除网桥# datapath类型分为netdev和system两种类型# netdev类型：dpdk用户态数据通过；system类型：对应linux内核数据通路# ovs-vsctl set bridge br0 datapath_type=netdev # 设置datapath类型ovs-vsctl get bridge br0 datapath_type # 查看datapath typeovs-vsctl set bridge br0 other_config:datapath-id=新dpid # 修改交换机dpidovs-vsctl get bridge br0 datapath-id # 查看datapath idovs-vsctl del-controller br0 # 删除控制器ovs-vsctl set-controller br0 tcp:1.2.3.4:6633 # 设置single controller# 查询 Controller 设定，如果有成功连到 controller 则会显示 is_connected:true, 反之未连上ovs-vsctl list controller # 查看控制器列表ovs-vsctl del-fail-mode br0 # 移除fail-modeovs-vsctl get-fail-mode br0 # 查询fail-mode# in-band模式下，控制器与OVS交换机连接的网口既可以有控制流量，又可以有数据流量。# out-of-band模式下，控制器与OVS交换机连接的网口只有控制流量。# OpenvSwitch不仅仅是一个OpenFlow Switch，它的流表组成除了of流表外，还有其他一些（隐藏）流表。这些隐藏流表默认交换机和控制器在同一网络中（in-band），因此要保证两者互通,要关闭默认的inband。ovs-vsctl get controller br0 connection-mode # 查询连接模式ovs-vsctl set controller br0 connection-mode=out-of-band # 设置br0连接模式为out-of-bandovs-vsctl set controller br0 connection-mode=in-band # 设置br0连接模式为in-bandovs-vsctl list-br # 查看有哪些桥ovs-vsctl list bridge br0 # 查看网桥的配置信息ovs-vsctl list-ports br0 # 查看桥中有哪些portsovs-vsctl list port br0 eth0.0 # 查看网桥段端口配置信息# stp协议：防止网桥网络中的冗余链路形成环路工作ovs-vsctl get bridge br0 stp_enable # 查看ovs交换机是否开启stp协议ovs-vsctl set bridge br0 stp_enable=true # 设置交换机开启stp协议ovs-vsctl get Interface eth0.0 ofport # 获取网络接口的OpenFlow编号ovs-vsctl set Interface eth0 type=internal # 设置 port 为 internal# 设置可选项ovs-vsctl set Interface eth0.0 options:link_speed=1Govs-vsctl remove Interface eth0.0 options link_speed# 设置fail模式，支持standalone或者secureovs-vsctl del-fail-mode br0ovs-vsctl set-fail-mode br0 secureovs-vsctl get-fail-mode br0# 关于OpenFlow versionovs-vsctl set bridge br0 protocols=OpenFlow12,OpenFlow13ovs-vsctl clear bridge br0 protocolsovs-ofctl dump-flows br0 # 查看网桥流表信息ovs-ofctl del-flows br0 # 删除网桥流表ovs-ofctl show br0 # 查看网桥各端口流表状态信息vs-vsctl get Interface br0 ofport # 获得br0网络接口的OpenFlow编号 OpenVSwitch中常见的port类型介绍： netdev: 通用网卡设备包括物理网卡以及虚拟网卡接收：网卡收到报文后回直接通过OpenvSwitch接收函数处理，不会再走传统内核协议栈；发送：OpenvSwitch中的一条flow指定从网卡port发出时通过该网卡设备发送。 internal: OpenvSwitch创建的一种虚拟网卡设备接收：OpenvSwitch所在主机通过internal设备网卡发送的报文(协议栈路由查找通过internal设备发送)，就进入OpenvSwitch接收处理函数.。报文送入OpenvSwitch处理；发送：OpenvSwitch中的一条flow指定从internal port发出时，该报文被重新注入内核协议栈， 标记为从internal网卡接收。 gre device: L2 gre tunnel设备接收：协议栈收到gre报文后，传递给L4层解析gre header, 然后传递给OpenvSwitch接收处理函数；发送：OpenvSwitch中的一条flow指定从gre设备发送, 报文会根据flow规则加上gre header和ip header，查找路由发送","categories":[{"name":"软件定义网络","slug":"软件定义网络","permalink":"http://www.li2ui2.xyz/categories/%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"软件定义网络","slug":"软件定义网络","permalink":"http://www.li2ui2.xyz/tags/%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C/"},{"name":"Netgear R6220交换机","slug":"Netgear-R6220交换机","permalink":"http://www.li2ui2.xyz/tags/Netgear-R6220%E4%BA%A4%E6%8D%A2%E6%9C%BA/"},{"name":"OpenvSwitch交换机","slug":"OpenvSwitch交换机","permalink":"http://www.li2ui2.xyz/tags/OpenvSwitch%E4%BA%A4%E6%8D%A2%E6%9C%BA/"}]},{"title":"SDN(三) RYU控制器相关笔记","slug":"SDN-三-RYU控制器相关笔记","date":"2020-11-20T05:55:28.000Z","updated":"2020-11-20T06:07:19.171Z","comments":true,"path":"2020/11/20/SDN-三-RYU控制器相关笔记/","link":"","permalink":"http://www.li2ui2.xyz/2020/11/20/SDN-%E4%B8%89-RYU%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/","excerpt":"","text":"1 引言积跬步以至千里，积怠情以至深渊。 RYU是由日本NTT公司研发的开源SDN控制器，由Python语言编写。支持OpenFlow1.0、1.2、1.3、1.4和1.5版本的协议。本人将在此文档中持续更新关于RYU控制器的一些学习笔记，包括RYU的运行流程、部分源码解读、应用开发以及RYU具体使用。望读者能在共同学习的同时，批评指正。 2 RYU源码解读2.1 RYU源文件目录结构ryu/ryu目录下的主要目录内容如下： (1) base： base中有一个非常重要的文件：app_manager.py，其作用是RYU应用的管理中心，即对其他组件的管理。用于加载RYU应用程序，接受从APP发送过来的信息，同时也完成消息的路由。会被ryu-manager自动调用。 其主要的函数有app注册、注销、查找、并定义了RyuApp基类，定义了RYUAPP的基本属性。包含name, threads, events, event_handlers和observers等成员，以及对应的许多基本函数。如：start(), stop()等。 这个文件中还定义了AppManager基类，用于管理APP。定义了加载APP等函数。不过如果仅仅是开发APP的话，这个类可以不必关心。 (2) controller： 实现controller和交换机之间的互联和事件处理 controller文件夹中许多非常重要的文件，如events.py, ofp_handler.py, controller.py等。在controller.py中定义了OpenFlowController基类，是控制器组件，管理与OF交换机连接的安全通道，接收OF消息，调用ofp_events，并发布相应的“事件”，以触发订阅了该“事件”的组件的处理逻辑。 在ofp_handler.py中定义了基本的handler，完成了基本的如：握手，错误信息处理和keep alive 等功能。更多的如packet_in_handler应该在app中定义。 在dpset.py文件中，定义了交换机端的一些消息，如端口状态信息等，用于描述和操作交换机。如添加端口，删除端口等操作。 (3) lib：网络基本协议的实现和使用 lib中定义了我们需要使用到的基本的数据结构，如dpid, mac和ip等数据结构。在lib/packet目录下，还定义了许多网络协议，如ICMP, DHCP, MPLS和IGMP等协议内容。而每一个数据包的类中都有parser和serialize两个函数。用于解析和序列化数据包。 lib目录下，还有ovs, netconf目录，对应的目录下有一些定义好的数据类型 (4) ofproto 在这个目录下，基本分为两类文件，一类是协议的数据结构定义，另一类是协议解析，也即数据包处理函数文件。 (5) topology：交换机和链路的查询模块 包含了switches.py等文件，基本定义了一套交换机的数据结构。event.py定义了交换上的事件。dumper.py定义了获取网络拓扑的内容。最后api.py向上提供了一套调用topology目录中定义函数的接口。 (6) contrib：第三方库 这个文件夹主要存放的是开源社区贡献者的代码。 (7) cmd：入口函数 定义了RYU的命令系统，为controller的执行创建环境，接收和处理相关命令 (8) services 完成了BGP (路由技术) 和vrrp (交换技术) 的实现 (9) teststests目录下存放了单元测试以及整合测试的代码。 2.2 ryu/app目录下源码解读及相关API的使用2.2.1 ryu/app/simple_switch_13.py实现功能为：传统的2层交换机策略对于OpenFlow交换机，接受RYU控制器的指令，并达到以下功能：对于接收到的数据包进行修改或针对指定端口进行转发；对于接收到的数据包进行转发到控制器的动作（packet-in）；对于接收到来自控制器的数据包进行转发到指定的端口（packet-out） 对于RYU来说，接收到任何一个OpenFlow消息，都会产生一个相对应事件，因此RYU应用必须实现事件管理以处理相对应的事件。 NT： simple_switch.py、 simple_switch_12.py、simple_switch_13.py、simple_switch_14.py和simple_switch_15.py分别对应OpenFlow1.0、1.2、1.4、1.5版本的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124from ryu.base import app_managerfrom ryu.controller import ofp_eventfrom ryu.controller.handler import CONFIG_DISPATCHER, MAIN_DISPATCHERfrom ryu.controller.handler import set_ev_clsfrom ryu.ofproto import ofproto_v1_3from ryu.lib.packet import packetfrom ryu.lib.packet import ethernetfrom ryu.lib.packet import ether_types# 继承ryu.base.app_manager.RyuAppclass SimpleSwitch13(app_manager.RyuApp): OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION] # 指定OpenFlow 1.3版本 def __init__(self, *args, **kwargs): super(SimpleSwitch13, self).__init__(*args, **kwargs) self.mac_to_port = &#123;&#125; # 定义MAC地址列表 # set_ev_cls指定事件类别得以接受消息和交换机状态作为参数 # 其中事件类别名称为ryu.controller.ofp_event.EventOFP+&lt;OpenFlow消息名称&gt; # 例如：在 Packet-In 消息的状态下的事件名称为EventOFPPacketIn # 对于交换机的状态来说，可指定以下中的一项 # ryu.controller.handler.HANDSHAKE_DISPATCHER 交换 HELLO 消息 # ryu.controller.handler.CONFIG_DISPATCHER 接收SwitchFeatures消息 # ryu.controller.handler.MAIN_DISPATCHER 一般状态 # ryu.controller.handler.DEAD_DISPATCHER 连线中断 @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER) def switch_features_handler(self, ev): # ev.msg 是用来存储对应事件的 OpenFlow 消息类别实体 # msg.datapath是用来存储OpenFlow交换机的 ryu.controller.controller.Datapath 类别所对应的实体 datapath = ev.msg.datapath ofproto = datapath.ofproto # ofproto表示使用的OpenFlow版本所对应的ryu.ofproto.ofproto_v1_3 parser = datapath.ofproto_parser # 和ofproto一样，有对应版本ryu.ofproto.ofproto_v1_3_parser # 下发table-miss流表项，让交换机对于不会处理的数据包通过packet-in消息上交给Ryu控制器！！！ # 匹配数据包 # 若数据包没有 match 任何一个普通 Flow Entry 时，则触发 Packet-In match = parser.OFPMatch() # 通过预留端口ofproto.OFPP_CONTROLLER，将packet-in消息发送给controller，并通过ofproto.OFPCML_NO_BUFFE指明Racket-in消息的原因是table miss actions = [parser.OFPActionOutput(ofproto.OFPP_CONTROLLER, ofproto.OFPCML_NO_BUFFER)] # 执行 add_flow() 方法以发送 Flow Mod 消息 self.add_flow(datapath, 0, match, actions) def add_flow(self, datapath, priority, match, actions, buffer_id=None): # 新增流表项 ofproto = datapath.ofproto parser = datapath.ofproto_parser # Apply Actions 是用来设定那些必须立即执行的 action 所使用 inst = [parser.OFPInstructionActions(ofproto.OFPIT_APPLY_ACTIONS, actions)] # 通过 Flow Mod 消息将 Flow Entry 新增到 Flow table 中 if buffer_id: mod = parser.OFPFlowMod(datapath=datapath, buffer_id=buffer_id, priority=priority, match=match, instructions=inst) else: mod = parser.OFPFlowMod(datapath=datapath, priority=priority, match=match, instructions=inst) datapath.send_msg(mod) @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER) def _packet_in_handler(self, ev): # If you hit this you might want to increase # the &quot;miss_send_length&quot; of your switch if ev.msg.msg_len &lt; ev.msg.total_len: self.logger.debug(&quot;packet truncated: only %s of %s bytes&quot;, ev.msg.msg_len, ev.msg.total_len) # 为了接收处理未知目的地的数据包，需要执行Packet-In 事件管理 msg = ev.msg # 每一个事件类ev中都有msg成员，用于携带触发事件的数据包 datapath = msg.datapath # 已经格式化的msg其实就是一个packet_in报文，msg.datapath直接可以获得packet_in报文的datapath结构 # datapath用于描述一个交换网桥，也是和控制器通信的实体单元。 # datapath.send_msg()函数用于发送数据到指定datapath。 # 通过datapath.id可获得dpid数据。 ofproto = datapath.ofproto # datapath.ofproto对象是一个OpenFlow协议数据结构的对象，成员包含OpenFlow协议的数据结构，如动作类型OFPP_FLOOD parser = datapath.ofproto_parser # datapath.ofp_parser则是一个按照OpenFlow解析的数据结构。 # 更新Mac地址表 in_port = msg.match[&#x27;in_port&#x27;] pkt = packet.Packet(msg.data) eth = pkt.get_protocols(ethernet.ethernet)[0] if eth.ethertype == ether_types.ETH_TYPE_LLDP: # ignore lldp packet return dst = eth.dst src = eth.src dpid = datapath.id self.mac_to_port.setdefault(dpid, &#123;&#125;) self.logger.info(&quot;packet in %s %s %s %s&quot;, dpid, src, dst, in_port) # learn a mac address to avoid FLOOD next time. self.mac_to_port[dpid][src] = in_port # 判断转发的数据包的连接端口 # 目的 MAC 位址若存在于 MAC 地址表，则判断该连接端口号码为输出。 # 反之若不存在于 MAC 地址表则 OUTPUT action 类别的实体并生成 flooding（ OFPP_FLOOD ）给目的连接端口使用。 if dst in self.mac_to_port[dpid]: out_port = self.mac_to_port[dpid][dst] else: out_port = ofproto.OFPP_FLOOD actions = [parser.OFPActionOutput(out_port)] # install a flow to avoid packet_in next time if out_port != ofproto.OFPP_FLOOD: match = parser.OFPMatch(in_port=in_port, eth_dst=dst, eth_src=src) # verify if we have a valid buffer_id, if yes avoid to send both # flow_mod &amp; packet_out if msg.buffer_id != ofproto.OFP_NO_BUFFER: self.add_flow(datapath, 1, match, actions, msg.buffer_id) return else: self.add_flow(datapath, 1, match, actions) # 在 MAC 地址表中找寻目的 MAC 地址，若是有找到则发送 Packet-Out 讯息，并且转送数据包。 data = None if msg.buffer_id == ofproto.OFP_NO_BUFFER: data = msg.data out = parser.OFPPacketOut(datapath=datapath, buffer_id=msg.buffer_id, in_port=in_port, actions=actions, data=data) datapath.send_msg(out) 可结合Mininet进行测试，相关操作如下：创建topo： 1sudo mn --topo single,3 --mac --switch ovsk --controller remote -x 查看ovs-vswitchd的配置信息： 1ovs-vsctl show 查看datapath的信息： 1ovs-dpctl show 设定交换机s1的Openflow版本： 1ovs-vsctl set Bridge s1 protocols=OpenFlow13 查看交换机s1的流表信息： 1ovs-ofctl -O OpenFlow13 dump-flows s1 主机h1网络抓包： 1tcpdump -en -i h1-eth0 NT：实验过程可结合ifconfig 命令用来查看和配置网络设备！！！例如： 12345678910ifconfig eth0 up # 启动 &lt;br&gt;ifcfg etho up # 启动ifconfig eth0 down # 关闭&lt;br&gt;ifcfg eth0 down # 关闭ifconfig eth0 hw ether 00:AA:BB:CC:DD:EE # 修改MAC地址ifconfig eth0 reload # 重启ifconfig eth0 add 33ffe:3240:800:1005::2/64 # 为网卡eth0配置IPv6地址 ifconfig eth0 del 33ffe:3240:800:1005::2/64 # 为网卡eth0删除IPv6地址ifconfig eth0 192.168.25.166 netmask 255.255.255.0 up # 为网卡eth0配置IPv4地址ifconfig eth0:ws arp # 启用ARP协议ifconfig eth0:ws -arp # 关闭ARP协议ifconfig eth0 mtu 1500 # 设置最大传输单元 2.2.2 ryu/app/simple_monitor_13.py实现功能为：定期检查网络状态当网络发生异常时，需快速找到原因，并且尽快回复原状。而找出网络中的错误、发现真正的原因需要清楚地知道网络地状态，假设网络中某个端口正处于高流量的状态，不论是因为它是一个不正常的状态或是任何原因导致，变成一个由于没有持续监控所发生的问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101from operator import attrgetterfrom ryu.app import simple_switch_13from ryu.controller import ofp_eventfrom ryu.controller.handler import MAIN_DISPATCHER, DEAD_DISPATCHERfrom ryu.controller.handler import set_ev_clsfrom ryu.lib import hubclass SimpleMonitor13(simple_switch_13.SimpleSwitch13): # 定期的向交换机发出要求以取得需要统计的数据 def __init__(self, *args, **kwargs): super(SimpleMonitor13, self).__init__(*args, **kwargs) self.datapaths = &#123;&#125; self.monitor_thread = hub.spawn(self._monitor) # 建立一个绿色线程，运行监控程序 # EventOFPStatureChange的信息类用来监测交换器的连线中断，会被触发在#Dathpath状态改变时 # 参数二表示 一般状态和连线中断状态 @set_ev_cls(ofp_event.EventOFPStateChange, [MAIN_DISPATCHER, DEAD_DISPATCHER]) def _state_change_handler(self, ev): # 通过判断当前状态从监测列表添加或移除当前datapath # 连线中断状态用于确认连线中的交换机可以持续被监控 datapath = ev.datapath # 当datapath的状态变成MAIN_DISPATCHER时，代表交换机已经被注册，并且正处于被监视的状态 if ev.state == MAIN_DISPATCHER: if datapath.id not in self.datapaths: self.logger.debug(&#x27;register datapath: %016x&#x27;, datapath.id) self.datapaths[datapath.id] = datapath # 当datapath的状态变成DEAD_DISPATCHER时，代表注册状态已经解除 elif ev.state == DEAD_DISPATCHER: if datapath.id in self.datapaths: self.logger.debug(&#x27;unregister datapath: %016x&#x27;, datapath.id) del self.datapaths[datapath.id] def _monitor(self): while True: # 不断地注册的向交换机发送要求取得的统计信息 for dp in self.datapaths.values(): self._request_stats(dp) # 每隔10s查询一次当前的监视datapath名单中的各个#datapath状况 hub.sleep(10) def _request_stats(self, datapath): self.logger.debug(&#x27;send stats request: %016x&#x27;, datapath.id) ofproto = datapath.ofproto parser = datapath.ofproto_parser # 向指定的datapath发送OFPFlowStatsRequest和OFPStatsResquest消息类实体，即对相关统计信息进行 # 请求 # OFPFlowStatsRequest主要用来对交换机的Flow Entry取得统计信息 # 对于交换即发出的要求可以使用table ID、output port、cookie 值和 match 条件来限定范围，但是以下实现的是取得所有的 Flow Entry。 req = parser.OFPFlowStatsRequest(datapath) datapath.send_msg(req) # OFPPortStatsRequest 是用来取得关于交换机的端口相关信息以及统计信息。 # 使用的使用可以指定端口号，以下使用OFPP_ANY，目的是要取得所有的端口统计信息。 req = parser.OFPPortStatsRequest(datapath, 0, ofproto.OFPP_ANY) datapath.send_msg(req) # 对FlowStatsReply消息的回复进行事件处理 @set_ev_cls(ofp_event.EventOFPFlowStatsReply, MAIN_DISPATCHER) def _flow_stats_reply_handler(self, ev): # body中存放了OFPFlowStats的列表，存储了每一个Flow Entry的统计资料，并作为OFPFlowStatsRequest的回应 body = ev.msg.body self.logger.info(&#x27;datapath &#x27; &#x27;in-port eth-dst &#x27; &#x27;out-port packets bytes&#x27;) self.logger.info(&#x27;---------------- &#x27; &#x27;-------- ----------------- &#x27; &#x27;-------- -------- --------&#x27;) # 对各个优先级非0的流表项按接收端口和目的MAC地址进行排序后遍历 for stat in sorted([flow for flow in body if flow.priority == 1], key=lambda flow: (flow.match[&#x27;in_port&#x27;], flow.match[&#x27;eth_dst&#x27;])): # 对交换机的datapath.id，目的MAC地址，输出端口和包以及字节流量进行打印 self.logger.info(&#x27;%016x %8x %17s %8x %8d %8d&#x27;, ev.msg.datapath.id, stat.match[&#x27;in_port&#x27;], stat.match[&#x27;eth_dst&#x27;], stat.instructions[0].actions[0].port, stat.packet_count, stat.byte_count) # 对PortStatsReply消息的回复事件进行处理 @set_ev_cls(ofp_event.EventOFPPortStatsReply, MAIN_DISPATCHER) def _port_stats_reply_handler(self, ev): body = ev.msg.body self.logger.info(&#x27;datapath port &#x27; &#x27;rx-pkts rx-bytes rx-error &#x27; &#x27;tx-pkts tx-bytes tx-error&#x27;) self.logger.info(&#x27;---------------- -------- &#x27; &#x27;-------- -------- -------- &#x27; &#x27;-------- -------- --------&#x27;) # 根据端口号进行排序并遍历 for stat in sorted(body, key=attrgetter(&#x27;port_no&#x27;)): # 打印交换机id，端口号和接收及发送的包的数量字节数和错误数 self.logger.info(&#x27;%016x %8x %8d %8d %8d %8d %8d %8d&#x27;, ev.msg.datapath.id, stat.port_no, stat.rx_packets, stat.rx_bytes, stat.rx_errors, stat.tx_packets, stat.tx_bytes, stat.tx_errors) 在Ryubook中给出了OFPFlowStats的JSON格式的全部信息，下面给出OFPPortStats的JSON数据信息： 2.2.3 /ryu/app/simple_switch_rest_13.py关于ofctl_rest.py的用法参考链接 RYU本身提供了一个类似WSGI的web服务器功能。借助这个功能，我们可以创建一个REST API。基于创建的REST API，可以快速的将RYU系统与其他系统或者是浏览器相连接。 REST：表征性状态传输（英文：Representational State Transfer，简称REST）是Roy Fielding博士在2000年他的博士论文中提出来的一种软件架构风格。REST架构风格中，资源是通过URI来描述的。对资源的操作采用了HTTP的GET，POST，PUT和DELETE方法相对应。资源的表现形式可以是json或xml。REST的架构是Client-Server架构，同时链接是无状态的。所以要求在传输的过程中需要包含状态信息。 代码解析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120import jsonfrom ryu.app import simple_switch_13from ryu.controller import ofp_eventfrom ryu.controller.handler import CONFIG_DISPATCHERfrom ryu.controller.handler import set_ev_clsfrom ryu.app.wsgi import ControllerBasefrom ryu.app.wsgi import Responsefrom ryu.app.wsgi import routefrom ryu.app.wsgi import WSGIApplicationfrom ryu.lib import dpid as dpid_libsimple_switch_instance_name = &#x27;simple_switch_api_app&#x27;# 指定url为如下方式，其中，&#123;dpid&#125; 的部分必須與 ryu/lib/dpid.pyurl = &#x27;/simpleswitch/mactable/&#123;dpid&#125;&#x27;class SimpleSwitchRest13(simple_switch_13.SimpleSwitch13): &quot;&quot;&quot; 更新交换机的MAC地址表 &quot;&quot;&quot; _CONTEXTS = &#123;&#x27;wsgi&#x27;: WSGIApplication&#125; # 用来建立Ryu中WSGI网页服务器所对应的类别，因此可通过wsgi Key来取得网页服务器的实体 def __init__(self, *args, **kwargs): super(SimpleSwitchRest13, self).__init__(*args, **kwargs) self.switches = &#123;&#125; wsgi = kwargs[&#x27;wsgi&#x27;] # 通过上一步设置的_CONTEXTS成员变量，可以通过kwargs进行实例化一个WSGIApplication。 wsgi.register(SimpleSwitchController, &#123;simple_switch_instance_name: self&#125;) # 使用register方法注册该服务到controller类上。 # 重写父类的switch_features_handler函数 @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER) def switch_features_handler(self, ev): super(SimpleSwitchRest13, self).switch_features_handler(ev) datapath = ev.msg.datapath self.switches[datapath.id] = datapath # 存储datapath到switches self.mac_to_port.setdefault(datapath.id, &#123;&#125;) # 初始化MAC地址表 def set_mac_to_port(self, dpid, entry): &quot;&quot;&quot; 该方法将MAC地址和端口注册到指定的交换机。该方法主要被REST API的PUT方法所调用。 &quot;&quot;&quot; # 获取MAC table mac_table = self.mac_to_port.setdefault(dpid, &#123;&#125;) # 获取datapath,如果为None，证明没有该交换机 datapath = self.switches.get(dpid) entry_port = entry[&#x27;port&#x27;] entry_mac = entry[&#x27;mac&#x27;] if datapath is not None: parser = datapath.ofproto_parser # # 如果entry_port不在mac_table中 if entry_port not in mac_table.values(): # 下发流表 for mac, port in mac_table.items(): # from known device to new device actions = [parser.OFPActionOutput(entry_port)] match = parser.OFPMatch(in_port=port, eth_dst=entry_mac) self.add_flow(datapath, 1, match, actions) # from new device to known device actions = [parser.OFPActionOutput(port)] match = parser.OFPMatch(in_port=entry_port, eth_dst=mac) self.add_flow(datapath, 1, match, actions) # 添加entry_mac, entry_port到mac_table mac_table.update(&#123;entry_mac: entry_port&#125;) return mac_tableclass SimpleSwitchController(ControllerBase): &quot;&quot;&quot; 定义收到HTTP请求时所需要回应的操作 &quot;&quot;&quot; def __init__(self, req, link, data, **config): super(SimpleSwitchController, self).__init__(req, link, data, **config) self.simple_switch_app = data[simple_switch_instance_name] # 借助route装饰器关联方法和URL, # 第一个参数：任何自定义名称; # 第二个参数：指明URL; # 第三个参数：指定http方法; # 第四个参数：指明指定位置的格式，URL(/simpleswitch/mactable/&#123;dpid&#125; 匹配DPID_PATTERN的描述 # 当使用GET方式访问到该REST API接口时，调用list_mac_table函数！！ @route(&#x27;simpleswitch&#x27;, url, methods=[&#x27;GET&#x27;], requirements=&#123;&#x27;dpid&#x27;: dpid_lib.DPID_PATTERN&#125;) def list_mac_table(self, req, **kwargs): simple_switch = self.simple_switch_app # 获取&#123;dpid&#125; dpid = dpid_lib.str_to_dpid(kwargs[&#x27;dpid&#x27;]) # 如果没有dpid,返回404 if dpid not in simple_switch.mac_to_port: return Response(status=404) # 获取mac_table mac_table = simple_switch.mac_to_port.get(dpid, &#123;&#125;) body = json.dumps(mac_table) return Response(content_type=&#x27;application/json&#x27;, body=body) # 使用PUT方式设置mac_table @route(&#x27;simpleswitch&#x27;, url, methods=[&#x27;PUT&#x27;], requirements=&#123;&#x27;dpid&#x27;: dpid_lib.DPID_PATTERN&#125;) def put_mac_table(self, req, **kwargs): simple_switch = self.simple_switch_app dpid = dpid_lib.str_to_dpid(kwargs[&#x27;dpid&#x27;]) try: new_entry = req.json if req.body else &#123;&#125; except ValueError: raise Response(status=400) if dpid not in simple_switch.mac_to_port: return Response(status=404) try: mac_table = simple_switch.set_mac_to_port(dpid, new_entry) body = json.dumps(mac_table) return Response(content_type=&#x27;application/json&#x27;, body=body) except Exception as e: return Response(status=500) 2.2.4 ryu/app/gui_topology/gui_topology.py实现功能为：定期检查网络状态ryu4.3版本和ryu3.14版本打开gui方式有所不同，本人安装版本为4.3。进入gui_topology文件夹进行，并运行如下命令 1ryu-manager --observe-links gui_topology.py 用mininet模拟了一个深度为3的树状网络拓扑，并连接到ryu，命令如下： 1sudo mn --controller remote --mac --topo tree,2,2 连接成功后，访问http://localhost:8080（我的ryu和mininet均运行在本机），即可看到如下界面：物理实验，打开一个openflow交换机，访问http://localhost:8080，看到界面如下： 2.2.5 /ryu/app/simple_switch_lacp_13.py实现的功能为：链路聚合网络聚合（ Link Aggregation ）是由 IEEE802.1AX-2008 所制定的，多条实体线路合并为一条逻辑线路（即，多个物理端口汇聚在一起，形成一个逻辑端口），以实现出/入流量吞吐量在各成员端口的负荷分担，交换机根据用户配置的端口负荷分担策略决定网络封包从哪个成员端口发送到对端的交换机。当交换机检测到其中一个成员端口的链路发生故障时，就停止在此端口上发送封包，并根据负荷分担策略在剩下的链路中重新计算报文的发送端口，故障端口回复再次担任收发端口。 因此链路聚合的实现可以让网络中特定的装置间通信速度提升、同时确保支援能力、提升容错的功能。可通过LACP（ Link Aggregation Control Protocol ）协议动态方法实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105from ryu.base import app_managerfrom ryu.controller import ofp_eventfrom ryu.controller.handler import CONFIG_DISPATCHERfrom ryu.controller.handler import MAIN_DISPATCHERfrom ryu.controller.handler import set_ev_clsfrom ryu.ofproto import ofproto_v1_3from ryu.lib import lacplibfrom ryu.lib.dpid import str_to_dpidfrom ryu.lib.packet import packetfrom ryu.lib.packet import ethernetfrom ryu.app import simple_switch_13class SimpleSwitchLacp13(simple_switch_13.SimpleSwitch13): OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION] _CONTEXTS = &#123;&#x27;lacplib&#x27;: lacplib.LacpLib&#125; def __init__(self, *args, **kwargs): super(SimpleSwitchLacp13, self).__init__(*args, **kwargs) self.mac_to_port = &#123;&#125; # 通过成员变量_CONTEXTS，可以通过kwargs进行实例化一个lacplib的应用程序。 self._lacp = kwargs[&#x27;lacplib&#x27;] # 通过LACP的add()方法来完成初始化设置， # 以下代码的初始化设置为： # datapath ID为0000000000000001的OpenFlow交换机的端口1和端口2整合为一个网络聚合群组 self._lacp.add( dpid=str_to_dpid(&#x27;0000000000000001&#x27;), ports=[1, 2]) def del_flow(self, datapath, match): &quot;&quot;&quot; 当端口有效/无效状态变更时，被逻辑链路所使用的实体链路会因为数据包的通过而改变状态。 因此，需要删除已经被记录的流表项 &quot;&quot;&quot; ofproto = datapath.ofproto parser = datapath.ofproto_parser mod = parser.OFPFlowMod(datapath=datapath, command=ofproto.OFPFC_DELETE, out_port=ofproto.OFPP_ANY, out_group=ofproto.OFPG_ANY, match=match) datapath.send_msg(mod) @set_ev_cls(lacplib.EventPacketIn, MAIN_DISPATCHER) def _packet_in_handler(self, ev): &quot;&quot;&quot; 需要由lacplib.EventPacketIn来装饰自定义的Packet-In函数 &quot;&quot;&quot; msg = ev.msg datapath = msg.datapath ofproto = datapath.ofproto parser = datapath.ofproto_parser in_port = msg.match[&#x27;in_port&#x27;] pkt = packet.Packet(msg.data) eth = pkt.get_protocols(ethernet.ethernet)[0] dst = eth.dst src = eth.src dpid = datapath.id self.mac_to_port.setdefault(dpid, &#123;&#125;) self.logger.info(&quot;packet in %s %s %s %s&quot;, dpid, src, dst, in_port) # learn a mac address to avoid FLOOD next time. self.mac_to_port[dpid][src] = in_port if dst in self.mac_to_port[dpid]: out_port = self.mac_to_port[dpid][dst] else: out_port = ofproto.OFPP_FLOOD actions = [parser.OFPActionOutput(out_port)] # install a flow to avoid packet_in next time if out_port != ofproto.OFPP_FLOOD: match = parser.OFPMatch(in_port=in_port, eth_dst=dst) self.add_flow(datapath, 1, match, actions) data = None if msg.buffer_id == ofproto.OFP_NO_BUFFER: data = msg.data out = parser.OFPPacketOut(datapath=datapath, buffer_id=msg.buffer_id, in_port=in_port, actions=actions, data=data) datapath.send_msg(out) @set_ev_cls(lacplib.EventSlaveStateChanged, MAIN_DISPATCHER) def _slave_state_changed_handler(self, ev): &quot;&quot;&quot; 当端口的状态变更为有效或者无效时，需要通过EventSlaveStateChanged事件来进行处理 &quot;&quot;&quot; datapath = ev.datapath dpid = datapath.id port_no = ev.port enabled = ev.enabled self.logger.info(&quot;slave state changed port: %d enabled: %s&quot;, port_no, enabled) if dpid in self.mac_to_port: for mac in self.mac_to_port[dpid]: match = datapath.ofproto_parser.OFPMatch(eth_dst=mac) self.del_flow(datapath, match) del self.mac_to_port[dpid] self.mac_to_port.setdefault(dpid, &#123;&#125;) 2.2.6 /ryu/app/simple_switch_stp_13.py实现功能为：生成树协议生成树是为了防止网络的拓扑中出现环路而产生广播风暴、占用交换机大量资源的技术。生成树有许多种类，例如STP、RSTP、PVST+、MSTP等不同的种类。详细介绍参考博客。 下边将介绍Ryu中的STP协议的实现 STP可以消除网络中的环路。其基本理论依据是根据网络拓扑构建（生成）无回路的连通图（就是树），从而保证数据传输路径的唯一性，避免出现环路导致报文流量的增加和循环。STP是工作在OSI第二层（Data Link Layer）的协议，通过在交换机之间传递特殊的消息并进行分布式的计算，来决定在一个有环路的网络中，某台交换机的某个端口应该被阻塞，用这种方法来避免掉环路。 STP作用： 消除环路：通过阻断冗余链路来消除网络中可能存在的环路；链路备份：当活动路径发生故障时，激活备份链路，及时恢复网络连通性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106from ryu.base import app_managerfrom ryu.controller import ofp_eventfrom ryu.controller.handler import CONFIG_DISPATCHER, MAIN_DISPATCHERfrom ryu.controller.handler import set_ev_clsfrom ryu.ofproto import ofproto_v1_3from ryu.lib import dpid as dpid_libfrom ryu.lib import stplibfrom ryu.lib.packet import packetfrom ryu.lib.packet import ethernetfrom ryu.app import simple_switch_13class SimpleSwitch13(simple_switch_13.SimpleSwitch13): OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION] _CONTEXTS = &#123;&#x27;stplib&#x27;: stplib.Stp&#125; def __init__(self, *args, **kwargs): super(SimpleSwitch13, self).__init__(*args, **kwargs) self.mac_to_port = &#123;&#125; self.stp = kwargs[&#x27;stplib&#x27;] # Sample of stplib config. # please refer to stplib.Stp.set_config() for details. config = &#123;dpid_lib.str_to_dpid(&#x27;0000000000000001&#x27;): &#123;&#x27;bridge&#x27;: &#123;&#x27;priority&#x27;: 0x8000&#125;&#125;, dpid_lib.str_to_dpid(&#x27;0000000000000002&#x27;): &#123;&#x27;bridge&#x27;: &#123;&#x27;priority&#x27;: 0x9000&#125;&#125;, dpid_lib.str_to_dpid(&#x27;0000000000000003&#x27;): &#123;&#x27;bridge&#x27;: &#123;&#x27;priority&#x27;: 0xa000&#125;&#125;&#125; self.stp.set_config(config) def delete_flow(self, datapath): ofproto = datapath.ofproto parser = datapath.ofproto_parser for dst in self.mac_to_port[datapath.id].keys(): match = parser.OFPMatch(eth_dst=dst) mod = parser.OFPFlowMod( datapath, command=ofproto.OFPFC_DELETE, out_port=ofproto.OFPP_ANY, out_group=ofproto.OFPG_ANY, priority=1, match=match) datapath.send_msg(mod) @set_ev_cls(stplib.EventPacketIn, MAIN_DISPATCHER) def _packet_in_handler(self, ev): msg = ev.msg datapath = msg.datapath ofproto = datapath.ofproto parser = datapath.ofproto_parser in_port = msg.match[&#x27;in_port&#x27;] pkt = packet.Packet(msg.data) eth = pkt.get_protocols(ethernet.ethernet)[0] dst = eth.dst src = eth.src dpid = datapath.id self.mac_to_port.setdefault(dpid, &#123;&#125;) self.logger.info(&quot;packet in %s %s %s %s&quot;, dpid, src, dst, in_port) # learn a mac address to avoid FLOOD next time. self.mac_to_port[dpid][src] = in_port if dst in self.mac_to_port[dpid]: out_port = self.mac_to_port[dpid][dst] else: out_port = ofproto.OFPP_FLOOD actions = [parser.OFPActionOutput(out_port)] # install a flow to avoid packet_in next time if out_port != ofproto.OFPP_FLOOD: match = parser.OFPMatch(in_port=in_port, eth_dst=dst) self.add_flow(datapath, 1, match, actions) data = None if msg.buffer_id == ofproto.OFP_NO_BUFFER: data = msg.data out = parser.OFPPacketOut(datapath=datapath, buffer_id=msg.buffer_id, in_port=in_port, actions=actions, data=data) datapath.send_msg(out) @set_ev_cls(stplib.EventTopologyChange, MAIN_DISPATCHER) def _topology_change_handler(self, ev): dp = ev.dp dpid_str = dpid_lib.dpid_to_str(dp.id) msg = &#x27;Receive topology change event. Flush MAC table.&#x27; self.logger.debug(&quot;[dpid=%s] %s&quot;, dpid_str, msg) if dp.id in self.mac_to_port: self.delete_flow(dp) del self.mac_to_port[dp.id] @set_ev_cls(stplib.EventPortStateChange, MAIN_DISPATCHER) def _port_state_change_handler(self, ev): dpid_str = dpid_lib.dpid_to_str(ev.dp.id) of_state = &#123;stplib.PORT_STATE_DISABLE: &#x27;DISABLE&#x27;, stplib.PORT_STATE_BLOCK: &#x27;BLOCK&#x27;, stplib.PORT_STATE_LISTEN: &#x27;LISTEN&#x27;, stplib.PORT_STATE_LEARN: &#x27;LEARN&#x27;, stplib.PORT_STATE_FORWARD: &#x27;FORWARD&#x27;&#125; self.logger.debug(&quot;[dpid=%s][port=%d] state=%s&quot;, dpid_str, ev.port_no, of_state[ev.port_state]) 3 RYU的运行3.1 RYU基本操作a、RYU使用命令 使用命令格式如下： 1ryu-manager &lt;yourapp&gt; 如，进入ryu/app目录，运行simple_switch_13.py 1ryu-manager simple_switch_13.py b、RYU启动参数 1234567ryu-manager 启动ryu, 如果不加任何参数，则默认启动ofphandler模块。ryu-manager –h 查看帮助信息--verbose 打印详细debug信息--version 显示程序的版本号并退出--observe-links 自动下发LLDP，用于拓扑发现--ofp-tcp-listen-port 修改ryu的openflow tcp监听端口… 说明：若在启动RYU时使用了–observe-links参数，则RYU会收到非常大量的包含LLDP协议报文的PacketIn消息如果不对这一PacketIn消息进行特殊处理的话，很容易导致Ryu奔溃，无法正常工作！！！所以，为了避免这一问题，当你计划使用–observe-links启动Ryu时，在你处理PacketIn消息的函数开头，建议包含如下代码，即可解决问题： 123if eth.ethertype == ether_types.ETH_TYPE_LLDP: # ignore lldp packet return 3.2 RYU运行流程RYU的main函数在ryu/cmd/maneger.py文件中，main函数主要内容如下代码。 在main函数中，首先从CONF文件中读取出app list。如果ryu-manager命令中不带任何参数，则默认应用为ofp_handler应用 NT： ofp_handler应用主要用于处理OpenFlow消息，完成了基本的消息处理，如hello_handler，用于处理hello报文 紧接着实例化一个AppManager对象，调用load_apps函数将应用加载。调用create_contexts函数创建对应的contexts 然后调用instantiate_apps函数将app_list和context中的app均实例化。启动wsgi架构，提供web应用 最后将所有的应用作为任务，作为coroutine的task去执行，joinall使得程序必须等待所有的task都执行完成才可以退出程序。最后调用close函数，关闭程序，释放资源 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849def main(args=None, prog=None): _parse_user_flags() # 根据配置项的注册，读取配置文件/usr/loca/etc/ryu/ryu.conf的配置 try: CONF(args=args, prog=prog, project=&#x27;ryu&#x27;, version=&#x27;ryu-manager %s&#x27; % version, default_config_files=[&#x27;/usr/local/etc/ryu/ryu.conf&#x27;]) except cfg.ConfigFilesNotFoundError: CONF(args=args, prog=prog, project=&#x27;ryu&#x27;, version=&#x27;ryu-manager %s&#x27; % version) log.init_log() # 初始化打印log logger = logging.getLogger(__name__) # 根据配置文件的配置执行 log、pidfile if CONF.enable_debugger: msg = &#x27;debugging is available (--enable-debugger option is turned on)&#x27; logger.info(msg) else: hub.patch(thread=True) if CONF.pid_file: with open(CONF.pid_file, &#x27;w&#x27;) as pid_file: pid_file.write(str(os.getpid())) # 启动applist中的应用，若applist为空，则启动ofp_handler应用 app_lists = CONF.app_lists + CONF.app # keep old behavior, run ofp if no application is specified. if not app_lists: app_lists = [&#x27;ryu.controller.ofp_handler&#x27;] app_mgr = AppManager.get_instance() # 在AppManager类中获取实例 app_mgr.load_apps(app_lists) # 加载App contexts = app_mgr.create_contexts() # 创建运行环境，&quot;dpset&quot;/&quot;wsgi&quot; services = [] services.extend(app_mgr.instantiate_apps(**contexts)) # 启动App线程，App实例化 # ryu.controller.dpset.DPSet / rest_firewall.RestFirewallAPI / ryu.controller.ofp_handler.OFPHandler webapp = wsgi.start_service(app_mgr) # webapp启动 if webapp: thr = hub.spawn(webapp) services.append(thr) try: hub.joinall(services) # 调用t.wait(),执行等待，wait()方法使当前线程暂停执行并释放对象锁标志 # 循环join,直到有异常或者外部中断推迟 except KeyboardInterrupt: logger.debug(&quot;Keyboard Interrupt received. &quot; &quot;Closing RYU application manager...&quot;) finally: app_mgr.close() NT： Datapath类在RYU中极为重要，位于ryu/controller/controller.py中，每当一个datapath实体与控制器建立连接时，就会实例化一个Datapath的对象。Datapath为OVS内核模块，类似网桥，负责执行数据交换，也就是把从接受端口收到的数据包在流表中进行匹配，并执行匹配到的动作，一个Datapath关联一个flow table，一个flow table包含多个条目。 3.3 RYU应用开发ryu/base/app_manager.py文件中，实现了两个类RyuApp和AppManager。 RyuApp类是RYU封装好的APP基类，为应用开发提供基本的模板，用户只需要继承该类，即可开发应用，而注册对应的observer和handler都使用@derocator的形式，使得开发非常的简单高效。 AppManager类用于Application的管理，加载应用，运行应用，消息路由等功能，是RYU应用的调度中心。3.3.1 Event Handle在实现RYU各项功能时，需要用到事件管理（Event Handle）。因为对于RYU来说，接收到的任何一个OpenFlow消息都会产生一个相对应的事件。而在RYU的应用程序开发时，必须实现事件管理以处理相对应发生的事件。 Event Handle是一个拥有事件物件（Event Object）作为参数，并且使用”ryu.controller.handler.set_ev_cls”装饰的函数。 set_ev_cls 参数包括：指定事件类别得以接受消息、 交换机状态，其中 事件类别：名称命名规则ryu.controller.ofp_event.EventOFP + &lt;OpenFlow消息名称&gt;，例如在 Packet-In 消息的状态下的事件名称为EventOFPPacketIn。OpenFlow消息在ryu\\ofproto\\ofproto_v1_X_parser中可以查看。详细内容可参考RYU的API资料，或者这篇博客 交换机状态：对于交换机状态来说，可指定以下其一ryu.controller.handler.HANDSHAKE_DISPATCHER 交换HELLO 消息ryu.controller.handler.CONFIG_DISPATCHER 接收 SwitchFeatures消息ryu.controller.handler.MAIN_DISPATCHER 一般状态ryu.controller.handler.DEAD_DISPATCHER 连线中断 因此，处理事件函数的标准模板如下： 123@set_ev_cls(ofp_event.Event, DISPATCHER(s))def your_function(self, ev):... 简单说，@set_ev_cls(ofp_event.Event, DISPATCHER(s))的含义就是，当接收DISPATCHER(s)情况的Event事件进行your_function处理。 3.3.2 源代码其他细节说明OpenFlow协议中的细节：Match、Instructions 和 Action 在 OpenFlow 协议中的细节参考链接 ofproto函数库的使用：ofproto函数库是用来产生和解析OpenFlow消息的函数库。可参考链接 数据包处理协议：Ryu中提供了许多解析和包装数据包的协议，比如ARP、BGP、IPV4等，可参考链接 of-config函数库：of-config是用来管理OpenFlow交换机的一个通讯协议。of-config通讯协议被定义在 NETCONF（RFC 6241）标准中，可以对逻辑交换机的Port和Queue进行设定，参考链接 4 常见问题4.1 ryu-manager运行报错当ryu-manager被多次执行，或者ryu的监听端口6633被占用时，会运行报错。ryu控制器默认使用6633端口，因此应该首先查看哪个进程占用了这个端口，执行命令sudo lsof -i :6633。若该端口被占用，有如下两种方案解决办法： 直接将占用进程kill掉：sudo kill -9 pid（进程号） 将ryu的端口号设为其他不被占用的端口，如5555端口：ryu-manager –ofp-tcp-listen-port 5555 -verbose 参考本文部分内容参考：https://www.cnblogs.com/zxqstrong/p/4789105.htmlhttps://osrg.github.io/ryu-book/zh_tw/html/index.html","categories":[{"name":"软件定义网络","slug":"软件定义网络","permalink":"http://www.li2ui2.xyz/categories/%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"软件定义网络","slug":"软件定义网络","permalink":"http://www.li2ui2.xyz/tags/%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C/"},{"name":"RYU控制器","slug":"RYU控制器","permalink":"http://www.li2ui2.xyz/tags/RYU%E6%8E%A7%E5%88%B6%E5%99%A8/"}]},{"title":"SDN(二) 对TP-LINK TL-MR3420型号的OpenFlow交换机进行配置","slug":"SDN-二-对TP-LINK-TL-MR3420型号的OpenFlow交换机进行配置","date":"2020-11-20T05:51:06.000Z","updated":"2020-11-20T06:07:10.087Z","comments":true,"path":"2020/11/20/SDN-二-对TP-LINK-TL-MR3420型号的OpenFlow交换机进行配置/","link":"","permalink":"http://www.li2ui2.xyz/2020/11/20/SDN-%E4%BA%8C-%E5%AF%B9TP-LINK-TL-MR3420%E5%9E%8B%E5%8F%B7%E7%9A%84OpenFlow%E4%BA%A4%E6%8D%A2%E6%9C%BA%E8%BF%9B%E8%A1%8C%E9%85%8D%E7%BD%AE/","excerpt":"","text":"1 引言积跬步以至千里，积怠情以至深渊。 在本人博客SDN(一)中已经详细介绍了如何将TP-LINK TL-MR3420路由器刷成OpenFlow交换机，该无线路由器已具备支持SDN功能。本文将继续介绍并记录近期开展SDN实验的总结，本文主要介绍对OpenFlow交换机进行的相关配置，包括局域网端口配置、VLAN划分、无线端口配置、OpenFlow协议配置等。 2 配置须知2.1 路由器接口介绍官网给出了路由器设备内部构造图，介绍了基本接口。常见的无线路由器一般都有一个WAN口，也就是连接到外部网络的接口，其余2-4个口为LAN口，用来连接普通局域网，内部有一个网络交换机芯片，专门处理LAN接口之间的信息交换。通常无线路由的WAN口和LAN之间的路由工作模式一般都采用NAT方式。 这里简单介绍什么是NAT，NAT为私有网络服务，该网络中的主机使用私有IP地址，当私有网络内部的主机与外部Internet通信时，网关路由器负责将私有IP地址转换为全球IP地址，以便取得通信。 要了解交换机接口相关信息，需要使用到swconfig配置命令，使用该命令查看TL-MR3420接口信息如下图所示，eth0一共有5个接口，Port 0为CPU所用，当前状态为up开启状态；其余四个接口用于连接外部设备，为有线接口Port1~Port4。其中由于正在连接测试，Port1状态为up开启状态，其余三个接口为down未连接状态。 2.2 待配置文件介绍要配置的文件有三个，分别是network,openflow,以及wireless，它们都位于路由器的/etc/config目录下。openflow文件初始都一样，wireless基本也大同小异，这两个文件非常容易配置（若需要用OpenFlow管理无线网络的话，还需要配置/etc/config/wireless）。比较困难的是network文件，不同路由器之间可能差别比较大。 network文件network文件内容如下图所示，其中各个部分表示为： 7表示创建一个vlan，option vlan ‘1’和option ports ‘0 1 2 3 4’这两句，是说创建的vlan编号为1，路由器的端口0、1、2、3、4这个vlan中； 3中的option ifname ‘eth0’ 即是说，当前eth0网卡下的几个端口处于同一个vlan配置的属性，所以目前每一个端口1、2、3、4任意一个接口接上网线都可以访问内网192.168.1.1。可用eth0.X表示vlanX，即端口X； 4中的option ifname ‘eth1’是说4这一部分配置的是wan的属性。openflow文件这个文件相较于network简单多了，其中dpid就是一个编号，在网络中只有一个openflow路由器时不用修改；ofports即是需要用openflow功能管理的vlan；ofctl是SDN控制器的相关信息；mode是openflow协议的工作方式，有inband模式和outoband模式，在inband模式下，控制器与openflow交换机连接的网口既可以有控制流量，又可以有数据流量。而outoband模式下，控制器与openflow交换机连接的网口只能有控制流量。wireless文件修改/etc/config/wireless，将option disable 1为关闭路由器无线功能，option disable 0为开启路由器无线功能3 MR3420对应文件配置3.1 /etc/config/network文件 config interface 用来配置局域网端口。eth0.1用来连接内网，也可以用来连接控制器，只要设置控制器IP地址与网关；其余端口用于连接主机。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566config interface &#x27;loopback&#x27; option ifname &#x27;lo&#x27; option proto &#x27;static&#x27; option ipaddr &#x27;127.0.0.1&#x27; option netmask &#x27;255.0.0.0&#x27;config globals &#x27;globals&#x27; option ula_prefix &#x27;fd84:aa1a:857d::/48&#x27;config interface &#x27;lan&#x27; option ifname &#x27;eth0.1&#x27; option force_link &#x27;1&#x27; option type &#x27;bridge&#x27; option proto &#x27;static&#x27; option ipaddr &#x27;192.168.1.1&#x27; option netmask &#x27;255.255.255.0&#x27; option ip6assign &#x27;60&#x27;config interface &#x27;wan&#x27; option ifname &#x27;eth1&#x27; option proto &#x27;dhcp&#x27; config interface &#x27;wan6&#x27; option ifname &#x27;eth1&#x27; option proto &#x27;dhcpv6&#x27; config interface option ifname &#x27;eth0.2&#x27; option proto &#x27;static&#x27; config interface option ifname &#x27;eth0.3&#x27; option proto &#x27;static&#x27; config interface option ifname &#x27;eth0.4&#x27; option proto &#x27;static&#x27; config switch option name &#x27;switch0&#x27; option reset &#x27;1&#x27; option enable_vlan &#x27;1&#x27; config switch_vlan option device &#x27;switch0&#x27; option vlan &#x27;1&#x27; option vid &#x27;1&#x27; option ports &#x27;0t 1&#x27; config switch_vlan option device &#x27;switch0&#x27; option vlan &#x27;2&#x27; option vid &#x27;2&#x27; option ports &#x27;0t 2&#x27;config switch_vlan option device &#x27;switch0&#x27; option vlan &#x27;3&#x27; option vid &#x27;3&#x27; option ports &#x27;0t 3&#x27; config switch_vlan option device &#x27;switch0&#x27; option vlan &#x27;4&#x27; option vid &#x27;4&#x27; option ports &#x27;0t 4&#x27; config switch_vlan为配置局域网Vlan端口。Vlan划分的端口中0t代表MR3420型号的cpu，不同路由之间不同，可以用swconfig命令查看，拔掉所有的端口后仍然显示连接的就是cpu端口。 划分完后，重启网络，然后再次查看eth0信息，看是否划分正确。 1/etc/init.d/network restart 3.2 /etc/config/wireless文件把wifi-iface里的option network lan这行去掉就行，这样连接wifi时就不会与eth0,1(lan接口)处于同一个子网，用在转发层而不是控制层。wifi-device的名字原本为radio0，有些型号的路由器这里必须为wlan0否则无法用OpenFlow管理wifi。 123456789101112131415config wifi-device wlan0 option type mac80211 option channel 11 option hwmode 11g option path &#x27;pci0000:00/0000:00:00.0&#x27; option htmode HT20 # REMOVE THIS LINE TO ENABLE WIFI: option disabled 0config wifi-iface option device wlan0 option mode ap option ssid MR3420_OpenWRT option encryption none 3.3 /etc/config/openflow文件要修改两个地方，第一个是ofctl选项里要填上控制器正确的ip地址，可以用网线连接主机和端口1，在linux主机上用ifconfig命令来查看分配到的ip地址。第二个是ofports选项，填上所有用作openflow交换机端口。 123456config &#x27;ofswitch&#x27; option &#x27;dp&#x27; &#x27;dp0&#x27; option &#x27;dpid&#x27; &#x27;000000000001&#x27; option &#x27;ofports&#x27; &#x27;wlan0 eth0.2 eth0.3 eth0.4 eth1&#x27; option &#x27;ofctl&#x27; &#x27;tcp:192.168.1.10:6633&#x27; option &#x27;mode&#x27; &#x27;outofband&#x27; 4 测试4.1 RYU控制器验证在Ubuntu上使用RYU控制器进行验证，若运行控制器后没有出错，则证明已连接上控制器。首先随机选择一个控制器的脚本进行运行 1ryu-manager simple_switch_13.py 运行成功后，显示结果如下接着，需要开启OpenFlow功能，但开启时时需要运行/etc/functions.sh文件，而/etc下没有该文件，所以要将/lib/functions.sh复制到/etc下，运行如下命令： 1cp /lib/functions.sh /etc 重启路由器后，通过以下命令开和关闭openflow功能 12/etc/init.d/openflow start/etc/init.d/openflow stop 开启路由器的OpenFlow功能后，显示结果如下图，已成功连接上控制器，证明配置成功，接下来即可验证控制器的各种功能了。祝好运！ 4.2 POX控制器验证POX控制器当前仅支持到OpenFlow1.0版本，而我们的OpenFlow交换机为1.3版本。为验证POX控制器的不适用，进行实验结果如下图所示。 4.3 其他验证除了使用TL-MR3420型号的OpenFlow交换机进行实验外，本文还进行了一些其他机器的实验，和以上内容没有太大关联。RYU控制器与OpenFlow1.0版本的路由器：","categories":[{"name":"软件定义网络","slug":"软件定义网络","permalink":"http://www.li2ui2.xyz/categories/%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"OpenFlow交换机","slug":"OpenFlow交换机","permalink":"http://www.li2ui2.xyz/tags/OpenFlow%E4%BA%A4%E6%8D%A2%E6%9C%BA/"},{"name":"软件定义网络","slug":"软件定义网络","permalink":"http://www.li2ui2.xyz/tags/%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C/"},{"name":"TP-LINK TL-MR3420交换机","slug":"TP-LINK-TL-MR3420交换机","permalink":"http://www.li2ui2.xyz/tags/TP-LINK-TL-MR3420%E4%BA%A4%E6%8D%A2%E6%9C%BA/"}]},{"title":"SDN(一) 用OpenWRT将路由器刷成openflow交换机","slug":"SDN-一-用OpenWRT将路由器刷成openflow交换机","date":"2020-11-20T05:28:47.000Z","updated":"2020-11-20T06:07:51.274Z","comments":true,"path":"2020/11/20/SDN-一-用OpenWRT将路由器刷成openflow交换机/","link":"","permalink":"http://www.li2ui2.xyz/2020/11/20/SDN-%E4%B8%80-%E7%94%A8OpenWRT%E5%B0%86%E8%B7%AF%E7%94%B1%E5%99%A8%E5%88%B7%E6%88%90openflow%E4%BA%A4%E6%8D%A2%E6%9C%BA/","excerpt":"","text":"1 引言积跬步以至千里，积怠情以至深渊。 没想到还是正式步入了SDN这条康庄大道上。一切还需从初识Mininet-WIFI说起，以为SDN如仿真层面那般，一个模块对应一个现有设备，殊不知硬件层面诸多设备还需自行编译，手动刷入自需固件。编译有风险，刷固件需谨慎。在此分享折腾了本人几天时间的刷机历程——用OpenWRT将路由器刷成支持openflow协议的交换机，并将详细介绍编译开源系统OpenWRT路上踩过的坑以及解决方案。 2 刷机环境 Ubuntu 18.04 (64位) TP-Link TL-MR3420 v1 P.S. 路由器基本情况介绍，TL-MR3420是一款可刷OpenFlow的3G无线路由器（5G时代都来了，3G时代的老设备……当然是咸鱼来的），具体哪些路由器可以刷OpenFLow可以参考http://wiki.openwrt.org/toh/start#supported.hardware.-.router.type，根据经验，只要能搞到以上链接中的任一台交换机，按本教程走，基本上是都可以刷机成功的。本文路由器基本信息介绍如下图所示 3 下载OPenWRT源码编译3.1 安装依赖项本文采用从OpenWRT源码编译生成固件，在下载源码之前，需要在Ubuntu上安装相关编译环境 12sudo apt-get updatesudo apt-get install build-essential binutils flex bison autoconf gettext texinfo sharutils subversion libncurses5-dev ncurses-term gawk zlib1g-dev libssl-dev mercurial 3.2 下载OpenWRT源码踩坑1： 接下来以下步骤一定要都以非root身份来完成所有工作，经过多次失败查询多方教程得此结论。 2018年之后，OpenWRT与LEDE宣布合并，下载OpenWRT源码的方法发生了重大的变化。之前网上搜索到的下载方法已经不可用了，最好自行搜索完成进行确认后再clone，以免往后的步骤浪费不必要的时间。 12345# 克隆官方源用以下代码# git clone https://github.com/openwrt/openwrt.git# 或者克隆15.05分支Chaos Calmergit clone https://github.com/openwrt/chaos_calmer.git 下载源码后，切换到OpenWRT下，打开其中readme文件，并参考其中步骤，拷贝feeds.conf.default并命名为feeds.conf 12cd chaos_calmercp feeds.conf.default feeds.conf 而后更新并安装所有可用的feeds 12./scripts/feeds update -a./scripts/feeds install -a 踩坑2： 不要轻易复制教程代码，最好手敲一遍，确保符号是 - 而不是 – 4 下载openflow1.3源码目前本人好像已经找不到1.0版本的源码了，若有读者有资源，欢迎评论。将其克隆到本地，与openwrt在同一级目录下。 1git clone https://github.com/CPqD/openflow-openwrt.git 建立软链接，将openflow-1.3文件夹映射到openwrt的package目录下；并将openflow-1.3目录下的files文件夹映射到openwrt目录下。以下为本人建立软连接代码，读者应根据自己的目录进行软连接的建立。 1234cd ~/Workspace/OpenWRT/chaos_calmer/package/ln –s ~/Workspace/OpenWRT/openflow-openwrt/openflow-1.3/cd ~/Workspace/OpenWRT/chaos_calmer/ln –s ~/Workspace//OpenWRT/openflow-openwrt/openflow-1.3/files 5 配置编译1make menuconfig 踩坑3： 一定要到openwrt目录下运行以上代码，切勿看多方教程，运行了以上代码，又运行诸如make defconfig代码，不然会报出莫名奇妙的错误（具体在哪个教程上看到找不到了，反正本人试过一回，结果果然失败了）踩坑4： 在执行make menuconfig的时候，会报一个错误（Build dependency: Please install Git (git-core) &gt;= 1.6.5），解决方法为找到文件 openwrt/include/prereq-build.mk 的第148行 git clone 2&gt;&amp;1 | grep – –recursive改为 git version 执行成功后，进行如下几个重要配置： 选择CPU型号，可以在官方support device找到你的路由器，并查看对应型号，执行如下操作Target System — Atheros AR7xxx/AR9xxx 选择对应的路由型号，本人选择TL-MR3420，执行如下操作 Target Profile — TL-MR3420 选定Network，添加OpenFlow，执行如下操作Network — openflow 其他配置 添加LuCI，collection — luci，这是中文图形界面的设置，由于本实验路由器flsh内存只有4M，所以这 里不装，以免编译出来的固件大于4M，在更新固件操作时会失败； 添加utf8：Kernel modules — Native Language Support — kmod-nls-utf8 配置完编译内容设置后，执行编译命令make等待即可，后面的V=99是为了显示更多的编译信息，该过程需要联网。注意，执行时，大坑要来了！ 1make V=99 踩坑5： 执行最后编译命令时，会报以下错误百思不得其解，找了各种教程，进行了各种尝试均失败了，太难了，终于找到原因，原来是官方源码clone下来的文件中居然相比较于原始网站git.openwrt.org上的内容少了一个文件！！ 将丢失的010-automake-port-to-Perl-5.22-and-later.patch文件拷贝到chaos_calmer/tools/automake/patches下面。 最终进行大概2个小时左右的时间即可编译成功。 6 刷机编译完成后，会在bin文件夹下生成ar71xx文件夹，其中openwrt-ar71xx-generic-tl-mr3420-v1-squashfs-factory.bin文件会是我们需要的固件，该固件的命名规则为openwrt-系统版本-硬件平台-具体分支-设备型号-硬件版本-分区类型-固件类型.bin。本实验采用网页直接刷入固件，可以登录192.168.1.1，找到软件升级选项，按提示上传以上艰辛过程得到的固件更新即可。注意！刷机过程中不要断电，耐心等待，否则路由器会变砖。 7 验证刷机成功后默认无线关闭，需要用一条网线连接电脑和路由器lan口，用ssh登录到路由器，用户名为root。进入系统后，界面如下若想开启路由器的无线功能，修改/etc/config/wireless，将option disable 1改为0重启路由（重启wifi也行，输入wifi等待重启）即可。","categories":[{"name":"软件定义网络","slug":"软件定义网络","permalink":"http://www.li2ui2.xyz/categories/%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"OpenWRT","slug":"OpenWRT","permalink":"http://www.li2ui2.xyz/tags/OpenWRT/"},{"name":"OpenFlow交换机","slug":"OpenFlow交换机","permalink":"http://www.li2ui2.xyz/tags/OpenFlow%E4%BA%A4%E6%8D%A2%E6%9C%BA/"},{"name":"软件定义网络","slug":"软件定义网络","permalink":"http://www.li2ui2.xyz/tags/%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-11-19T05:04:58.875Z","updated":"2020-11-19T05:04:58.875Z","comments":true,"path":"2020/11/19/hello-world/","link":"","permalink":"http://www.li2ui2.xyz/2020/11/19/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"技巧","slug":"技巧","permalink":"http://www.li2ui2.xyz/categories/%E6%8A%80%E5%B7%A7/"},{"name":"树莓派","slug":"树莓派","permalink":"http://www.li2ui2.xyz/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"编程语言","slug":"编程语言","permalink":"http://www.li2ui2.xyz/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"人工智能","slug":"人工智能","permalink":"http://www.li2ui2.xyz/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"版本控制","slug":"版本控制","permalink":"http://www.li2ui2.xyz/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"数据库","slug":"数据库","permalink":"http://www.li2ui2.xyz/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.li2ui2.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"软件定义网络","slug":"软件定义网络","permalink":"http://www.li2ui2.xyz/categories/%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"Netgear路由器","slug":"Netgear路由器","permalink":"http://www.li2ui2.xyz/tags/Netgear%E8%B7%AF%E7%94%B1%E5%99%A8/"},{"name":"树莓派","slug":"树莓派","permalink":"http://www.li2ui2.xyz/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"Pycharm","slug":"Pycharm","permalink":"http://www.li2ui2.xyz/tags/Pycharm/"},{"name":"Python","slug":"Python","permalink":"http://www.li2ui2.xyz/tags/Python/"},{"name":"MTCNN人脸检测算法","slug":"MTCNN人脸检测算法","permalink":"http://www.li2ui2.xyz/tags/MTCNN%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/"},{"name":"Facenet人脸识别算法","slug":"Facenet人脸识别算法","permalink":"http://www.li2ui2.xyz/tags/Facenet%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E7%AE%97%E6%B3%95/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://www.li2ui2.xyz/tags/OpenCV/"},{"name":"Git","slug":"Git","permalink":"http://www.li2ui2.xyz/tags/Git/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://www.li2ui2.xyz/tags/MongoDB/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.li2ui2.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Mininet-WiFi","slug":"Mininet-WiFi","permalink":"http://www.li2ui2.xyz/tags/Mininet-WiFi/"},{"name":"POX控制器","slug":"POX控制器","permalink":"http://www.li2ui2.xyz/tags/POX%E6%8E%A7%E5%88%B6%E5%99%A8/"},{"name":"Gephi可视化平台","slug":"Gephi可视化平台","permalink":"http://www.li2ui2.xyz/tags/Gephi%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B3%E5%8F%B0/"},{"name":"Mininet","slug":"Mininet","permalink":"http://www.li2ui2.xyz/tags/Mininet/"},{"name":"网络仿真器","slug":"网络仿真器","permalink":"http://www.li2ui2.xyz/tags/%E7%BD%91%E7%BB%9C%E4%BB%BF%E7%9C%9F%E5%99%A8/"},{"name":"软件定义网络","slug":"软件定义网络","permalink":"http://www.li2ui2.xyz/tags/%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C/"},{"name":"ping命令原理","slug":"ping命令原理","permalink":"http://www.li2ui2.xyz/tags/ping%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86/"},{"name":"icmp协议","slug":"icmp协议","permalink":"http://www.li2ui2.xyz/tags/icmp%E5%8D%8F%E8%AE%AE/"},{"name":"arp协议","slug":"arp协议","permalink":"http://www.li2ui2.xyz/tags/arp%E5%8D%8F%E8%AE%AE/"},{"name":"Netgear R6220交换机","slug":"Netgear-R6220交换机","permalink":"http://www.li2ui2.xyz/tags/Netgear-R6220%E4%BA%A4%E6%8D%A2%E6%9C%BA/"},{"name":"OpenvSwitch交换机","slug":"OpenvSwitch交换机","permalink":"http://www.li2ui2.xyz/tags/OpenvSwitch%E4%BA%A4%E6%8D%A2%E6%9C%BA/"},{"name":"RYU控制器","slug":"RYU控制器","permalink":"http://www.li2ui2.xyz/tags/RYU%E6%8E%A7%E5%88%B6%E5%99%A8/"},{"name":"OpenFlow交换机","slug":"OpenFlow交换机","permalink":"http://www.li2ui2.xyz/tags/OpenFlow%E4%BA%A4%E6%8D%A2%E6%9C%BA/"},{"name":"TP-LINK TL-MR3420交换机","slug":"TP-LINK-TL-MR3420交换机","permalink":"http://www.li2ui2.xyz/tags/TP-LINK-TL-MR3420%E4%BA%A4%E6%8D%A2%E6%9C%BA/"},{"name":"OpenWRT","slug":"OpenWRT","permalink":"http://www.li2ui2.xyz/tags/OpenWRT/"}]}